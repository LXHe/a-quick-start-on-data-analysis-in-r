[["基本介绍.html", "第1章 基本介绍 1.1 变量赋值 1.2 数据类型 1.3 向量 1.4 缺失值 1.5 矩阵 1.6 数据框 1.7 数组 1.8 列表 1.9 字符串处理 1.10 常用函数", " 第1章 基本介绍 1.1 变量赋值 R中变量的赋值采用&lt;-(快捷键 “Alt”+“-”)或者=完成，左侧为变量名称，右侧为赋值内容。 变量命名时需要注意： 变量名称可以由字母或者点号.开头且只能是字母、数字、下划线_和点号.的组合。 变量名称对大小写敏感，所以在调用时需要区分大小写。 当用点号 . 开头时，第二个字符不能是数字。 变量名称不能用数字或下划线_开头。 预留变量或者函数名称(如TRUE，FALSE，NULL)不能用来命名。 # 给数字赋值 price &lt;- 2 print(price) ## [1] 2 # 给字符赋值 greeting &lt;- &quot;Hello!&quot; print(greeting) ## [1] &quot;Hello!&quot; 1.2 数据类型 R的基本数据类型包括三种：数字(numeric)、字符(character)和逻辑(logical)。 既可以使用class()函数查看变量的数据类型，也可以使用is.character()，is.numeric()判断数据类型。 将一种变量类型更改为另一种类型，可使用as.*函数，即as.numeric()，as.character()，as.logical() # 数字：浮点数或者整数 bmi &lt;- 26.6 print(class(bmi)) ## [1] &quot;numeric&quot; # 字符：用引号引用的文字或者数字 str_name &lt;- &quot;Tom&quot; print(class(str_name)) ## [1] &quot;character&quot; str_age &lt;- &quot;20&quot; print(class(str_age)) ## [1] &quot;character&quot; # 逻辑：“是”/“否”的判断 is.character(bmi) # 返回值为FALSE ## [1] FALSE is.character(str_name) # 返回值为TRUE ## [1] TRUE # 改变变量类型 as.numeric(str_age) ## [1] 20 as.logical(1) # 数字1为TRUE，0为FALSE ## [1] TRUE 1.3 向量 向量(vector)是多个值（数字、字符或逻辑值）的组合。创建向量可以使用c()函数，c代表concatenate。 math_score &lt;- c(60,75,87,99,22,44) print(math_score) ## [1] 60 75 87 99 22 44 student_name &lt;- c(&quot;小赵&quot;,&quot;小钱&quot;,&quot;小孙&quot;,&quot;小李&quot;,&quot;小周&quot;,&quot;小吴&quot;) print(student_name) ## [1] &quot;小赵&quot; &quot;小钱&quot; &quot;小孙&quot; &quot;小李&quot; &quot;小周&quot; &quot;小吴&quot; 向量中的值被称为元素(element)。使用names()函数可以给向量内的元素命名。在创立向量时，也可以直接给元素命名。 # 使用 names() 函数 names(math_score) &lt;- student_name print(math_score) ## 小赵 小钱 小孙 小李 小周 小吴 ## 60 75 87 99 22 44 # 创立向量时命名 english_score &lt;- c(&quot;小赵&quot;=85, &quot;小钱&quot;=70, &quot;小孙&quot;=42,&quot;小李&quot;=95,&quot;小周&quot;=39,&quot;小吴&quot;=67) print(english_score) ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 42 95 39 67 获取向量长度可以使用length()函数。 length(math_score) ## [1] 6 获取向量中的特定元素： 当知道元素名称时，可以根据元素名称获取元素。 有些向量并未给元素命名，此时也可以根据索引(index)获取元素。 注意： 元素的索引从1开始，直至最后一个元素(索引为向量的长度)。 当需要获取多个元素时，可以使用c()函数或者使用索引切片(slice)。 当需要获取连续的多个元素时，使用索引切片更为方便。 # 使用元素名称获取单个元素 math_score[&quot;小赵&quot;] ## 小赵 ## 60 # 使用c()函数获取多个元素 math_score[c(&quot;小赵&quot;,&quot;小李&quot;)] ## 小赵 小李 ## 60 99 # 使用索引获取多个元素 math_score[c(1,4,5)] ## 小赵 小李 小周 ## 60 99 22 # 使用索引切片获取连续的多个元素 math_score[3:length(math_score)] # 顺序获取元素 ## 小孙 小李 小周 小吴 ## 87 99 22 44 math_score[length(math_score):3] # 逆序获取元素 ## 小吴 小周 小李 小孙 ## 44 22 99 87 向向量添加元素可以使用append()函数。参数包括： vec指目标向量，即要把元素添加到的向量。 value指目标元素，即想要添加的元素。如果是单个元素，直接写赋值，如果是多个元素，需要使用c()函数。 index是可选参数，即要把新添加的元素插入到原先向量中哪个索引位置的后面，默认是插入到原有向量末尾。 注意：需要重新赋值变量才能将新生成的向量保存。 new_score &lt;- c(55, 89) english_score_new &lt;- append(english_score, new_score) # 未给定插入位置 print(english_score_new) ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 42 95 39 67 55 89 english_score_new2 &lt;- append(english_score, new_score, 2) # 给定插入位置 print(english_score_new2) ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 55 89 42 95 39 67 从向量移除元素可以使用 - 号。 print(english_score_new[-2]) # 从english_score_new向量移除第2个索引的元素 ## 小赵 小孙 小李 小周 小吴 ## 85 42 95 39 67 55 89 print(english_score_new[-c(2:4)]) #从english_score_new向量移除第2至第4个索引的元素 ## 小赵 小周 小吴 ## 85 39 67 55 89 print(english_score_new[-c(2,5,7)]) #从english_score_new向量移除第2、5、7个索引的元素 ## 小赵 小孙 小李 小吴 ## 85 42 95 67 89 1.3.1 按逻辑进行向量选择 R中的逻辑运算符： 运算符 含义 ＜ 小于 ＞ 大于 ＜= 小于等于 ＞= 大于等于 == 等于 != 不等于 %in% 包含 &amp; 和 | 或 bmi &lt;- c(26.5, 22.4, NA, 25.5, 31, 27, 20, NA, 19.4, 23, 30) bmi[bmi&lt;24] # 筛选BMI&lt;24的元素 ## [1] 22.4 NA 20.0 NA 19.4 23.0 bmi[bmi&gt;28] # 筛选BMI&gt;28的元素 ## [1] NA 31 NA 30 bmi[(bmi&lt;=20)|(bmi&gt;=30)] # 筛选BMI&lt;=20或者&gt;=30的元素 ## [1] NA 31.0 20.0 NA 19.4 30.0 bmi[bmi %in% c(24:30)] # 筛选BMI在[24,30]范围内的元素 ## [1] 27 30 bmi[(bmi&gt;=24)&amp;(bmi&lt;=30)] # 筛选BMI在[24,30]范围内的元素 ## [1] 26.5 NA 25.5 27.0 NA 30.0 注意：当向量中有缺失值 NA 时，上述的逻辑运算中，除了 %in% ，其余运算都会将缺失值囊括进来。 1.3.2 向量的极值 我们可以使用 max() 和 min() 函数分别获得向量的最大与最小值。 我们还可以使用 which.max() 和 which.min() 函数分别获得向量的最大与最小值对应的索引值。 max(bmi) # max()函数默认不会排除NA ## [1] NA max(bmi, na.rm=TRUE) ## [1] 31 which.max(bmi) # 返回最大值的索引值，这里的索引值是包含缺失值在内的索引值 ## [1] 5 which(bmi == max(bmi, na.rm=TRUE)) ## [1] 5 1.4 缺失值 缺失值通常有三种显示形式：NaN （Not a Number，非数值）、NULL（absence of value，空值）和 NA (Not Available，缺失值) 1.4.1 NaN R中的有些运算会导致结果为非数值，显示为 NaN，可以用 is.nan() 函数来判断。 0/0 ## [1] NaN is.nan(0/0) ## [1] TRUE 1.4.2 NULL R中的 NULL 表示空值，即没有内容，长度为0且不占位置，常用来初始化变量。可以用 is.null() 函数来判断。 x &lt;- NULL length(x) ## [1] 0 is.null(x) ## [1] TRUE 1.4.3 NA NA 是R中真正意义上的缺失值。可以用 is.na() 函数来判断。 sum(is.na(bmi)) # 获取缺失值数目 ## [1] 2 which(is.na(bmi)) # 获取缺失值的索引值 ## [1] 3 8 bmi[!is.na(bmi)] # 移除缺失值 ## [1] 26.5 22.4 25.5 31.0 27.0 20.0 19.4 23.0 30.0 na.omit(bmi) # 移除缺失值，同时显示缺失值的索引值 ## [1] 26.5 22.4 25.5 31.0 27.0 20.0 19.4 23.0 30.0 ## attr(,&quot;na.action&quot;) ## [1] 3 8 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; 在处理含有缺失值的向量时，很多函数在默认参数下不能工作（使用 ?函数 可以获取函数的详细介绍）。 mean(bmi) # 有缺失值时，函数在默认参数下不能工作 ## [1] NA mean(bmi, na.rm=TRUE) # 需要声明参数 ## [1] 24.97778 bmi_impute &lt;- bmi # 复制向量 bmi_impute[is.na(bmi_impute)] &lt;- mean(bmi_impute, na.rm=TRUE) # 对向量进行均值填补 writeLines(paste0(&quot;填补后的目标向量为：&quot;, list(round(bmi_impute, 2)), &quot;\\n&quot;, &quot;填补后的初始向量为：&quot;, list(bmi))) # 填补只会作用于（复制后的）目标向量，对初始向量无影响 ## 填补后的目标向量为：c(26.5, 22.4, 24.98, 25.5, 31, 27, 20, 24.98, 19.4, 23, 30) ## 填补后的初始向量为：c(26.5, 22.4, NA, 25.5, 31, 27, 20, NA, 19.4, 23, 30) 1.5 矩阵 矩阵(matrix)是m×n个数按照m行n列的方式排列形成的数表。R中的矩阵(matrix)可以通过matrix()函数、cbind()或rbind()函数生成。 matrix()函数用于将向量转变为m×n的矩阵，输入向量的长度必须等于m×n。 cbind()函数指column bind，即列的叠加，要求输入的向量或矩阵的行数相同。 rbind()函数指row bind，即行的叠加，要求输入的向量或矩阵的列数相同。 # matrix()函数生成矩阵 var_vector &lt;- c(1,2,3,4,5,6) var_matrix &lt;- matrix(var_vector, nrow=2) var_matrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 cbind(var_matrix, var_matrix) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 1 3 5 ## [2,] 2 4 6 2 4 6 rbind(var_matrix, var_matrix) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## [3,] 1 3 5 ## [4,] 2 4 6 矩阵的转置使用t()函数 t(var_matrix) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 矩阵中元素的提取采用[行索引,列索引]的方式。 var_matrix[1,2] # 提取第1行第2列的元素 ## [1] 3 var_matrix[1,c(2,3)] # 提取第1行第2、3列的元素 ## [1] 3 5 var_matrix[1,] # 提取第1行的所有元素 ## [1] 1 3 5 var_matrix[,2] # 提取第2列的所有元素 ## [1] 3 4 采用dim()函数获取矩阵的维度，nrow()函数获取矩阵的行数，ncol()函数获取矩阵的列数。 dim(var_matrix) ## [1] 2 3 nrow(var_matrix) ## [1] 2 ncol(var_matrix) ## [1] 3 1.6 数据框 矩阵只能包含一个种类的数据。 cbind(c(&quot;M&quot;,&quot;F&quot;), var_matrix) ## [,1] [,2] [,3] [,4] ## [1,] &quot;M&quot; &quot;1&quot; &quot;3&quot; &quot;5&quot; ## [2,] &quot;F&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; 如上所示，当加入字符型数据后，矩阵中的数字也被强制转变为字符型（即被双引号包裹），这被称为隐式强制。因此，使用数据框(dataframe)可以存储不同类型的数据，保留原有数据的完整性。 data(iris) # 调用R自带数据框做为演示 class(iris) # 查看数据类型 ## [1] &quot;data.frame&quot; dim(iris) # 查看数据框维度 ## [1] 150 5 str(iris) # 查看数据框内的变量类型 ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 1.7 数组 数组（array）是矩阵的扩展，可以将矩阵扩展至2维以上。1维数组相当于向量1.3，2维数组相当于矩阵1.5。R中使用array()函数创建数组，主要的参数为： X输入数据，可以是向量或者矩阵。 dim输出维度，如果输出多维度，使用c(m,n,k,..)，其中m×n为最内层矩阵。 var_array1 &lt;- array(seq(1:18), dim=c(3,6)) # 创建3×6维的数组 var_array1 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 4 7 10 13 16 ## [2,] 2 5 8 11 14 17 ## [3,] 3 6 9 12 15 18 var_array2 &lt;- array(seq(1:18), dim=c(3,2,3)) # 创建3×2×3维的数组 var_array2 ## , , 1 ## ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 ## ## , , 2 ## ## [,1] [,2] ## [1,] 7 10 ## [2,] 8 11 ## [3,] 9 12 ## ## , , 3 ## ## [,1] [,2] ## [1,] 13 16 ## [2,] 14 17 ## [3,] 15 18 var_array2[,,3] # 获取第3层的矩阵 ## [,1] [,2] ## [1,] 13 16 ## [2,] 14 17 ## [3,] 15 18 1.8 列表 列表（list）是R语言的对象集合，可以用来保存不同类型的数据，使用list()函数创建。与c()函数1.3不同，list()函数保留输入数据最初的数据结构，而c()函数将所有输入数据降维放入一个向量中。使用unlist()函数可以将列表转变为向量。 test_list &lt;- list(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), 23, matrix(c(1,2,3,4),nrow=2)) length(test_list) ## [1] 3 test_vector &lt;- c(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), 23, matrix(c(1,2,3,4),nrow=2)) length(test_vector) ## [1] 8 length(unlist(test_list)) # 使用`unlist()`函数将列表转变为向量 ## [1] 8 list()元素的获取采用[[]]+索引值的方式，添加元素使用append()函数。 注意：如果需要将整个向量添加进原有列表中，必须先将向量转为列表形式，否则R会将向量中的元素逐个添加为列表的元素。 test_list[[1]] # 使用[[]]获取列表中的元素 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; append(test_list, list(c(FALSE, FALSE, TRUE))) # 整个添加向量 ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[2]] ## [1] 23 ## ## [[3]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## [[4]] ## [1] FALSE FALSE TRUE append(test_list, c(FALSE, FALSE, TRUE)) # 逐个添加向量元素 ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## [[2]] ## [1] 23 ## ## [[3]] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## [[4]] ## [1] FALSE ## ## [[5]] ## [1] FALSE ## ## [[6]] ## [1] TRUE 1.9 字符串处理 在处理数据过程中，通常会碰到需要提取具有某一类特征的变量名或者需要从特定变量中筛选出包含某一类特征的字符串的情况。正则表达式（regular expression）就是帮助我们识别特定字符串的工具。 R中可以使用 grep 函数、grepl 函数或者调用 stringr 包的 str_view 函数进行正则表达式匹配： grep 函数返回目标字符串所在的位置（即索引值）。 grepl 函数返回逻辑向量。 stringr 包的 str_view 函数返回目标字符串，str_detect函数返回逻辑向量。 正则表达式主要依赖于元字符，其具体含义如下表： 元字符 含义 [] 匹配方括号内的任意字符（可以任意组合） [^] 匹配除方括号内字符以外的任意字符 * 匹配大于等于0个在*号之前的重复字符 + 匹配至少1个在+号之前的重复字符 ? 匹配至多1个在+号之前的重复字符 {n} 匹配正好n个在{}号之前的字符 {n,} 匹配至少n个在{}号之前的字符 {n,m} 匹配至少n个，至多m个在{}号之前的字符 () 匹配与括号内完全相同的字符（数目与排序必须完全一致） | 匹配|符号前或后的字符 ^ ^之后的字符位于开始端 $ $之前的字匹配字符位于末端 \\ 转义字符，用于匹配保留的元字符 .[]*+?{}()\\^$ 正则表达式也提供一些常用的字符集简写，如下表所示： 简写 含义 . 除换行符外的所有字符 \\d 匹配所有数字，等同于[0-9] \\D 匹配所有非数字，等同于[^0-9] \\w 匹配所有字母、数字和下划线，等同于[a-zA-Z0-9_] \\W 匹配所有非字母、数字和下划线，等同于[^a-zA-Z0-9_] \\t 匹配水平制表符 \\n 匹配换行符 \\s 匹配所有空格字符（空格、制表符或换行符） \\S 匹配所有非空格字符（空格、制表符或换符行） 注意： 在R中使用正则表达式时，字符型常量中一个\\要写成两个\\\\。 使用字符集简写时，grep 函数的 perl 参数需要被设定成 TRUE。 # 创建字符串向量 var_name &lt;- c(&quot;cn-Bmi_2014&quot;, &quot;cn_-bMi-2015&quot;, &quot;uk-bmi_2014&quot;, &quot;uk-bm i_2015&quot;, &quot;ck_bmi_2014&quot;, &quot;ck_bmi_2015&quot;, &quot;cn_bim_2014&quot;, &quot;uk_bim_2014&quot;, &quot;ck_b im_2014&quot;) # 查找包含BMI的变量 var_name[grep(&quot;bmi|bm i&quot;, var_name, ignore.case=TRUE)] ## [1] &quot;cn-Bmi_2014&quot; &quot;cn_-bMi-2015&quot; &quot;uk-bmi_2014&quot; &quot;uk-bm i_2015&quot; &quot;ck_bmi_2014&quot; ## [6] &quot;ck_bmi_2015&quot; # 查找cn和uk的BMI变量 var_name[grep(&quot;^(cn|uk)[\\\\w-]+bmi&quot;, var_name, ignore.case=TRUE, perl=TRUE)] ## [1] &quot;cn-Bmi_2014&quot; &quot;cn_-bMi-2015&quot; &quot;uk-bmi_2014&quot; # 查找ck 2014年的变量 var_name[grep(&quot;^ck[\\\\w\\\\s-]+2014$&quot;, var_name, ignore.case=TRUE, perl=TRUE)] ## [1] &quot;ck_bmi_2014&quot; &quot;ck_b im_2014&quot; # 调用stringr包 library(stringr) str_view(var_name, &quot;bmi&quot;) # 大小写敏感 ## [3] │ uk-&lt;bmi&gt;_2014 ## [5] │ ck_&lt;bmi&gt;_2014 ## [6] │ ck_&lt;bmi&gt;_2015 # 默认大小写敏感，如果想忽略大小写，需要用regex(ignore_case=TRUE)说明 str_view(var_name, regex(&quot;bmi&quot;, ignore_case=TRUE)) ## [1] │ cn-&lt;Bmi&gt;_2014 ## [2] │ cn_-&lt;bMi&gt;-2015 ## [3] │ uk-&lt;bmi&gt;_2014 ## [5] │ ck_&lt;bmi&gt;_2014 ## [6] │ ck_&lt;bmi&gt;_2015 有时我们也会碰到在字符串的前后有空格的情况，这时我们可以用 [\\\\s]* 去进行正则表达式匹配或者使用 stringr 包的 str_trim 函数移除位于字符串两端的空格。 library(stringr) trim_list &lt;- c(&quot; the &quot;, &quot; good&quot;, &quot;b ad &quot;) str_trim(trim_list) ## [1] &quot;the&quot; &quot;good&quot; &quot;b ad&quot; 1.10 常用函数 1.10.1 seq()函数 seq() 函数用于生成一组数字序列，seq 代表 sequence。参数包括： from 数字序列起点，默认为1。 to 数字序列终点。 by 步长，可以为正数、负数或者小数。 length.out 生成数字序列的长度。 along.with 生成与目标序列相同长度的数字序列。 seq(from=0, to=6, by=3) # 从0开始，在[0,6]范围内生成以3为步长的数字序列 ## [1] 0 3 6 seq(from=1, to=6, by=3) # 超出范围的数字将不会被纳入到数字序列中 ## [1] 1 4 seq(from=0, by=3, length.out=4) # 从0开始，以3为步长，生成一个包含4个元素的数字序列 ## [1] 0 3 6 9 # 从1开始，以2为步长，生成一个与month.abb相同长度的数字序列 seq(from=1, by=2, along.with=month.abb) ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 1.10.2 rep()函数 rep()函数用于生成重复序列，rep 代表 repeat。参数包括： x 想要进行复制的对象，可以是一个数字，字符或者向量。 times 对整个目标对象复制的次数，只能为正整数。 each 对目标对象内元素复制的次数，只能为正整数。 length.out 生成序列的长度。 rep(1:3, times=3) # 对向量c(1,2,3)复制2次 ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, times=c(3,2,1)) # 对向量c(1,2,3)内的元素分别复制3、2、1次 ## [1] 1 1 1 2 2 3 rep(1:3, each=2) # 对向量c(1,2,3)内的元素各复制2次 ## [1] 1 1 2 2 3 3 rep(c(&quot;abc&quot;, &quot;bbb&quot;), time=3, length.out=3) # 超过的长度自动截断 ## [1] &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; rep(c(&quot;abc&quot;, &quot;bbb&quot;), time=3, length.out=9) # 不足的长度自动填补 ## [1] &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; 1.10.3 unique()函数 unique()函数用于移除重复值。 unique(c(1,2,2,3,4,3,2)) ## [1] 1 2 3 4 1.10.4 sample()函数 sample()函数用于随机抽样。参数包括： x 想要进行抽样的向量。 size 想要进行抽样的向量。 replace 默认为FALSE，即不重复抽样，此时 size 不能大于 x。若为TRUE，则为重复抽样，此时 size 可以大于 x。 prob 向量中各元素被抽到的概率，默认为NULL，即概率相同。 注意：在进行随机抽样前，使用 set.seed() 函数设置随机种子可以保证抽样结果的复现。随机种子的赋值只需初始化一次。 # set.seed(1) sample(1:6, size=10, replace=TRUE) # 从[1,6]中重复地随机抽取10个元素 ## [1] 4 4 1 1 1 6 2 6 1 5 1.10.5 combn()函数 combn()函数用于获得目标向量中指定长度的所有组合，常用于需要遍历变量组合的情况。参数包括： x 目标向量。 m 指定组合长度。 simplify 默认为TRUE，即返回矩阵。若为FALSE，则返回列表。 var_list &lt;- c(&quot;bmi&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;education&quot;) # 生成变量向量 combn(var_list, 3) # 将var_list内的三个元素随机组合，返回为矩阵 ## [,1] [,2] [,3] [,4] ## [1,] &quot;bmi&quot; &quot;bmi&quot; &quot;bmi&quot; &quot;age&quot; ## [2,] &quot;age&quot; &quot;age&quot; &quot;sex&quot; &quot;sex&quot; ## [3,] &quot;sex&quot; &quot;education&quot; &quot;education&quot; &quot;education&quot; combn(var_list, 3)[,1] # 获取返回矩阵的第一个组合 ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; combn(var_list, 3, simplify=FALSE) # 将变量var_list内的三个元素随机组合，返回为列表 ## [[1]] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; ## ## [[2]] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;education&quot; ## ## [[3]] ## [1] &quot;bmi&quot; &quot;sex&quot; &quot;education&quot; ## ## [[4]] ## [1] &quot;age&quot; &quot;sex&quot; &quot;education&quot; combn(var_list, 3, simplify=FALSE)[[1]] # 获取返回列表的第一个组合 ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; 1.10.6 paste()函数 paste()函数用于将向量、数字或字符合并成字符串，常用于特定语句的生成。 sep参数用于定义将不同向量或字符合并成字符串所用的连接符。 collapse参数用于定义将单一向量内元素合并成字符串所用的连接符。 # 将不同向量或字符合并成字符串 paste(&quot;are&quot;, &quot;you&quot;, &quot;OK&quot;, sep=&quot; &quot;) # 返回一个字符串 ## [1] &quot;are you OK&quot; paste0(&quot;are&quot;, &quot;you&quot;, &quot;OK&quot;) # paste0()与paste(sep=&quot;&quot;)一样 ## [1] &quot;areyouOK&quot; paste(var_list, &quot;cn&quot;, sep=&quot;-&quot;) # 返回包含字符串的向量 ## [1] &quot;bmi-cn&quot; &quot;age-cn&quot; &quot;sex-cn&quot; &quot;education-cn&quot; # 将单一向量内元素合并成字符串 paste(var_list, collapse=&quot;+&quot;) # 返回一个字符串 ## [1] &quot;bmi+age+sex+education&quot; 1.10.7 ifelse()函数 ifelse()函数为条件函数，包含三个参数： test 条件。 yes 条件为TRUE时的返回值。 no 条件为FALSE时的返回值。 此函数在条件判断中可以得到多个逻辑结果，返回对应数目的逻辑值并根据逻辑值赋值（注意与if(){}else{}函数1.10.8的区别）。此函数可以嵌套。 age &lt;- seq(1,4) target &lt;- c(2,2,4,4) ifelse(age==target, &quot;Y&quot;, &quot;N&quot;) # 可进行多个逻辑判断并分别返回值 ## [1] &quot;N&quot; &quot;Y&quot; &quot;N&quot; &quot;Y&quot; ifelse(age==1, &quot;age1&quot;, ifelse(age&lt;4, &quot;age2&quot;, &quot;age3&quot;)) ## [1] &quot;age1&quot; &quot;age2&quot; &quot;age2&quot; &quot;age3&quot; 1.10.8 if(){}else{}函数 ()内为判断条件，如果为真，则运行第一个{}的指令，否则运行第二个{}的指令。此判断条件中只接受一个逻辑结果。如果输入多个逻辑结果，将会报错，此时需要用any()或者all()函数对多个逻辑结果进行处理。使用多个else if(){}进行嵌套。 这些此函数与ifelse()函数1.10.7的区别。 if(any(age==c(1,1,1,1))){&quot;Y&quot;} else{&quot;N&quot;} ## [1] &quot;Y&quot; new_age &lt;- 55 if(new_age&lt;40){ &quot;青年&quot; } else if(new_age&lt;60){ &quot;中年&quot; } else {&quot;老年&quot;} ## [1] &quot;中年&quot; 1.10.9 循环 1.10.9.1 for循环 for循环是R语言中最常用的迭代函数之一，形式为for(){}： () 内为迭代器，即需要迭代的向量。 {} 内为想要运行的指令。 for(i in seq(1:4)){ print(paste0(&quot;现在的数字是：&quot;, i)) # 循环打印 } ## [1] &quot;现在的数字是：1&quot; ## [1] &quot;现在的数字是：2&quot; ## [1] &quot;现在的数字是：3&quot; ## [1] &quot;现在的数字是：4&quot; ini_num &lt;- 5 # 设定初始值 sum_container &lt;- c() # 创建空向量 for(i in seq(1,5,by=2)){ ini_num = ini_num + i # 迭代求和 sum_container &lt;- append(sum_container, ini_num) # 将求和值添加入向量 } sum_container ## [1] 6 9 14 1.10.9.2 while循环 while(){}循环将重复执行{}中的指令直至不能满足()中的条件。 init_num &lt;- 0 while(init_num&lt;4){ init_num = init_num + 1 print(paste0(&quot;已完成&quot;, init_num, &quot;次运算。&quot;)) } ## [1] &quot;已完成1次运算。&quot; ## [1] &quot;已完成2次运算。&quot; ## [1] &quot;已完成3次运算。&quot; ## [1] &quot;已完成4次运算。&quot; 1.10.9.3 apply()函数 当需要对矩阵或者数据框进行统一的特定处理时，为避免重复使用循环，可以选择apply()函数，返回类型为向量或矩阵。此函数中三个主要的参数为： X输入数据。 MARGIN指令执行方向。 FUN执行指令。 FUN MARGIN 指令执行说明 当指令需要作用于多个元素 MARGIN=1 逐行运行指令，返回向量 当指令需要作用于多个元素 MARGIN=2 逐列运行指令，返回向量 当指令只作用于单个元素 MARGIN=1 逐个运行指令，返回矩阵。可以理解为将数据转置后对单个元素进行处理。 当指令只作用于单个元素 MARGIN=2 逐个运行指令，返回矩阵。可以理解为在原有数据上直接对单个元素进行处理。 # apply()函数与矩阵 var_matrix &lt;- matrix(c(1,4,9,16,25,36),nrow=2) apply(var_matrix, 1, sum) # 指令作用于多个元素 ## [1] 35 56 apply(var_matrix, 2, sum) # 指令作用于多个元素 ## [1] 5 25 61 apply(var_matrix, 1, sqrt) # 指令作用于单个元素 ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 apply(var_matrix, 2, sqrt) # 指令作用于单个元素 ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # apply()函数与数据框 data(iris) apply(iris[,c(1,3)], 2, sum) # 对iris数据库中的第1、3列分别求和 ## Sepal.Length Petal.Length ## 876.5 563.7 当需要对列表进行统一的特定处理时，可以使用lapply()函数，返回类型为列表。主要参数为X即输入数据和FUN执行指令。当FUN作用于X内的单个元素时，X的结构不会发生改变。 var_vector_list &lt;- list(c(1,4,9), c(16,25,36)) lapply(var_vector_list, sum) ## [[1]] ## [1] 14 ## ## [[2]] ## [1] 77 lapply(var_vector_list, sqrt) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 var_matrix_list &lt;- list(matrix(c(1,4,9,16,25,36),nrow=2),matrix(c(1,4,9,16,25,36),nrow=2)) lapply(var_vector_list, sum) ## [[1]] ## [1] 14 ## ## [[2]] ## [1] 77 lapply(var_matrix_list, sqrt) ## [[1]] ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 当需要对列表、向量或数据框进行统一的特定处理且希望返回最简单的数据结构时，可以使用sapply()函数。 var_matrix &lt;- matrix(c(1,4,9,16,25,36),nrow=2) sapply(var_matrix, sum) # 返回向量 ## [1] 1 4 9 16 25 36 sapply(var_matrix, sqrt) # 返回向量 ## [1] 1 2 3 4 5 6 var_vector_list &lt;- list(c(1,4,9), c(16,25,36)) sapply(var_vector_list, sum) # 返回向量 ## [1] 14 77 sapply(var_vector_list, sqrt) # 返回矩阵 ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 var_matrix_list &lt;- list(matrix(c(1,4,9,16,25,36),nrow=2),matrix(c(1,4,9,16,25,36),nrow=2)) sapply(var_vector_list, sum) # 返回向量 ## [1] 14 77 sapply(var_matrix_list, sqrt) # 返回矩阵 ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 当需要对向量按类别进行统一的特定处理时，可以使用tapply()函数，返回数组。 data(iris) tapply(iris[,1], iris$Species, mean) ## setosa versicolor virginica ## 5.006 5.936 6.588 小结 函数 主要参数 输入数据类型 输出数据类型 apply apply(X,MARGIN,FUN) 矩阵、数据框 向量、矩阵 lapply lapply(X,FUN) 列表 列表 sapply sapply(X,FUN) 列表、矩阵、数据框 向量、矩阵 tapply tapply(X,INDEX,FUN) 向量 数组 1.10.10 自定义函数 function(){}用于自定义函数，其中()用于定义函数的参数，{}用于定义函数的指令并以return()定义要返回的数据。 # 定义一个函数，用于报告向量长度 length_report &lt;- function(x){ print(paste0(&quot;此向量的长度是：&quot;, length(x))) } length_report(c(&quot;bmi&quot;, &quot;grip&quot;, &quot;sex&quot;, &quot;age&quot;)) ## [1] &quot;此向量的长度是：4&quot; # 定义一个x+2y的函数，返回运算结果 multiply_function &lt;- function(x,y){ return(x+2*y) } result_multiply &lt;- multiply_function(2,3) # 传入参数位置与函数参数位置对应 result_multiply ## [1] 8 # 定义默认变量 multiply_function2 &lt;- function(x,y,z=&quot;运算完成！&quot;){ print(z) return(x+2*y) } multiply_function2(2,3) ## [1] &quot;运算完成！&quot; ## [1] 8 multiply_function2(2,3,&quot;哈哈，运算完成~&quot;) ## [1] &quot;哈哈，运算完成~&quot; ## [1] 8 函数只能返回一个结果，所以，如果有多个结果需要返回时，可以将结果整合为向量、列表或者数据框的形式之后再返回。 # 定义一个函数，获取向量内个元素累计叠加的值 accumulation &lt;- function(x){ init_num &lt;- x[1] # 获取第1个元素 result &lt;- c(init_num) # 建立result向量收集结果 if (length(x)&gt;=2){ for(i in seq(2,length(x))) { init_num &lt;- init_num + x[i] result &lt;- append(result, init_num) } } return(result) # 返回向量 } accumulation(c(1)) ## [1] 1 accumulation(seq(1:4)) ## [1] 1 3 6 10 "]]
