[["index.html", "R数据分析入门 本书说明 软件准备 R包的安装与调用", " R数据分析入门 Lingxiao HE 2024-04-12 本书说明 本教材旨在帮助大家快速入门R数据分析。通过学习本教材，希望您能： 阅读R代码 掌握基本的R代码编写 使用R读取和处理数据 使用R进行数据可视化 使用R进行常规的统计分析 软件准备 在开始学习前，请先安装R与RStudio： R下载链接：点击任意站点，进入后，选择下载与操作系统匹配的R软件。 RStudio下载链接 注意： 编写R代码时，所有的代码符号均为英文标点符号。 #是R中的注释符（快捷键为Shift+Ctrl+c），运行时不会执行#这一行的代码，通常被用作代码注释或者特定代码的测试。 在控制台（Console）输入 ?+函数 可以获取函数的详细介绍。 练习题链接 R包的安装与调用 R之所以广受欢迎，很大一个原因就是它拥有种类繁多的“包”以满足我们的多种需求。尽管R自带一些功能强大的“包”，但是我们在需要的时候还得额外安装“包”，否则，调用包就会报错。 这时就需要用到install.packages()函数。例如，当我们需要安装tidyverse包时，可以输入install.packages(\"tidyverse\")。 我们如果需要使用某一个“包”，则需要在开始时使用library()函数调用它。例如，我们在安装完tidyverse包后，调用它时可以输入 library(tidyverse)。 有时我们会在一个项目中调用多个包，而有些包里的函数会出现重名的情况，这时，后调用的“包”将覆盖先前加载“包”的功能。如果我们需要使用特定包的某个重名函数，可以输入包::函数。例如tseries和chron包都含有is.weekend()函数，如果要调用chron包的is.weekend()函数，则可以写成chron::is.weekend()。 当我们不清楚某个“包”是否有安装，可以使用if (!require(包)){install.packages(\"包\")}，这个代码的含义是，检查特定的包是否存在，如果不存在，将安装它。比如，检查tidyverse包是否存在，如果不存在则安装它，可以写成 if (!require(tidyverse)){install.packages(\"tidyverse\")} "],["基本介绍.html", "第1章 基本介绍 1.1 变量赋值 1.2 数据类型 1.3 向量 1.4 缺失值 1.5 矩阵 1.6 数据框 1.7 数组 1.8 列表 1.9 字符串处理 1.10 常用函数", " 第1章 基本介绍 1.1 变量赋值 R中变量的赋值采用&lt;-(快捷键 “Alt”+“-”)或者=完成，左侧为变量名称，右侧为赋值内容。 变量命名时需要注意： 变量名称可以由字母或者点号.开头且只能是字母、数字、下划线_和点号.的组合。 变量名称对大小写敏感，所以在调用时需要区分大小写。 当用点号 . 开头时，第二个字符不能是数字。 变量名称不能用数字或下划线_开头。 预留变量或者函数名称(如TRUE，FALSE，NULL)不能用来命名。 # 给数字赋值 price &lt;- 2 print(price) ## [1] 2 # 给字符赋值 greeting &lt;- &quot;Hello!&quot; print(greeting) ## [1] &quot;Hello!&quot; 1.2 数据类型 R的基本数据类型包括三种：数字(numeric)、字符(character)和逻辑(logical)。 既可以使用class()函数查看变量的数据类型，也可以使用is.character()，is.numeric()判断数据类型。 将一种变量类型更改为另一种类型，可使用as.*函数，即as.numeric()，as.character()，as.logical() # 数字：浮点数或者整数 bmi &lt;- 26.6 print(class(bmi)) ## [1] &quot;numeric&quot; # 字符：用引号引用的文字或者数字 str_name &lt;- &quot;Tom&quot; print(class(str_name)) ## [1] &quot;character&quot; str_age &lt;- &quot;20&quot; print(class(str_age)) ## [1] &quot;character&quot; # 逻辑：“是”/“否”的判断 is.character(bmi) # 返回值为FALSE ## [1] FALSE is.character(str_name) # 返回值为TRUE ## [1] TRUE # 改变变量类型 as.numeric(str_age) ## [1] 20 as.logical(1) # 数字1为TRUE，0为FALSE ## [1] TRUE 1.3 向量 向量(vector)是多个值（数字、字符或逻辑值）的组合。创建向量可以使用c()函数，c代表concatenate。 math_score &lt;- c(60,75,87,99,22,44) print(math_score) ## [1] 60 75 87 99 22 44 student_name &lt;- c(&quot;小赵&quot;,&quot;小钱&quot;,&quot;小孙&quot;,&quot;小李&quot;,&quot;小周&quot;,&quot;小吴&quot;) print(student_name) ## [1] &quot;小赵&quot; &quot;小钱&quot; &quot;小孙&quot; &quot;小李&quot; &quot;小周&quot; &quot;小吴&quot; 向量中的值被称为元素(element)。使用names()函数可以给向量内的元素命名。在创立向量时，也可以直接给元素命名。 # 使用 names() 函数 names(math_score) &lt;- student_name print(math_score) ## 小赵 小钱 小孙 小李 小周 小吴 ## 60 75 87 99 22 44 # 创立向量时命名 english_score &lt;- c(&quot;小赵&quot;=85, &quot;小钱&quot;=70, &quot;小孙&quot;=42,&quot;小李&quot;=95,&quot;小周&quot;=39,&quot;小吴&quot;=67) print(english_score) ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 42 95 39 67 获取向量长度可以使用length()函数。 length(math_score) ## [1] 6 获取向量中的特定元素： 当知道元素名称时，可以根据元素名称获取元素。 有些向量并未给元素命名，此时也可以根据索引(index)获取元素。 注意： 元素的索引从1开始，直至最后一个元素(索引为向量的长度)。 当需要获取多个元素时，可以使用名称或者使用索引切片(slice)。 当需要获取连续的多个元素时，使用索引切片更为方便。 # 使用元素名称获取单个元素 math_score[&quot;小赵&quot;] ## 小赵 ## 60 # 使用名称获取多个元素，注意需要使用c()生成向量 math_score[c(&quot;小赵&quot;,&quot;小李&quot;)] ## 小赵 小李 ## 60 99 # 使用索引获取多个元素 math_score[c(1,4,5)] ## 小赵 小李 小周 ## 60 99 22 # 使用索引切片获取连续的多个元素 math_score[3:length(math_score)] # 顺序获取元素 ## 小孙 小李 小周 小吴 ## 87 99 22 44 math_score[length(math_score):3] # 逆序获取元素 ## 小吴 小周 小李 小孙 ## 44 22 99 87 向向量添加元素可以使用append()函数。参数包括： vec指目标向量，即要把元素添加到的向量。 value指目标元素，即想要添加的元素。如果是单个元素，直接写赋值，如果是多个元素，需要使用c()函数。 index是可选参数，即要把新添加的元素插入到原先向量中哪个索引位置的后面，默认是插入到原有向量末尾。 注意：需要重新赋值变量才能将新生成的向量保存。 new_score &lt;- c(55, 89) # 未给定插入位置 english_score_new &lt;- append(english_score, new_score) english_score_new ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 42 95 39 67 55 89 # 给定插入位置 english_score_new2 &lt;- append(english_score, new_score, 2) english_score_new2 ## 小赵 小钱 小孙 小李 小周 小吴 ## 85 70 55 89 42 95 39 67 从向量移除元素可以使用 - 号。 # 从english_score_new向量移除第2个索引的元素 english_score_new[-2] ## 小赵 小孙 小李 小周 小吴 ## 85 42 95 39 67 55 89 #从english_score_new向量移除第2至第4个索引的元素 english_score_new[-c(2:4)] ## 小赵 小周 小吴 ## 85 39 67 55 89 #从english_score_new向量移除第2、5、7个索引的元素 english_score_new[-c(2,5,7)] ## 小赵 小孙 小李 小吴 ## 85 42 95 67 89 1.3.1 按逻辑进行向量选择 R中的逻辑运算符： 运算符 含义 ＜ 小于 ＞ 大于 ＜= 小于等于 ＞= 大于等于 == 等于 != 不等于 %in% 包含 &amp; 和 | 或 # 创建bmi向量 bmi &lt;- c(26.5, 22.4, NA, 25.5, 31, 27, 20, NA, 19.4, 23, 30) # 筛选BMI&lt;24的元素 bmi[bmi&lt;24] ## [1] 22.4 NA 20.0 NA 19.4 23.0 # 筛选BMI&gt;28的元素 bmi[bmi&gt;28] ## [1] NA 31 NA 30 # 筛选BMI&lt;=20或者&gt;=30的元素 bmi[(bmi&lt;=20)|(bmi&gt;=30)] ## [1] NA 31.0 20.0 NA 19.4 30.0 # 筛选BMI在向量(26,27,28,29,30)内的元素 bmi[bmi %in% c(26:30)] ## [1] 27 30 # 筛选BMI在[24,30]范围内的元素 bmi[(bmi&gt;=24)&amp;(bmi&lt;=30)] ## [1] 26.5 NA 25.5 27.0 NA 30.0 1.3.2 向量的极值 我们可以使用max()和min()函数分别获得向量的最大与最小值。 我们还可以使用which.max()和which.min()函数分别获得向量的最大与最小值对应的索引值。 # max()函数默认不会排除NA max(bmi) ## [1] NA max(bmi, na.rm=TRUE) ## [1] 31 # 返回最大值的索引值，这里的索引值是包含缺失值在内的索引值 which.max(bmi) ## [1] 5 which(bmi == max(bmi, na.rm=TRUE)) ## [1] 5 1.4 缺失值 缺失值通常有三种显示形式：NaN（Not a Number，非数值）、NULL（absence of value，空值）和 NA（Not Available，缺失值） 1.4.1 NaN R中的有些运算会导致结果为非数值，显示为NaN，可以用is.nan()函数来判断。 0/0 ## [1] NaN is.nan(0/0) ## [1] TRUE 1.4.2 NULL R中的NULL表示空值，即没有内容，长度为0且不占位置，常用来初始化变量。可以用is.null()函数来判断。 x &lt;- NULL length(x) ## [1] 0 is.null(x) ## [1] TRUE 1.4.3 NA NA是R中真正意义上的缺失值。可以用is.na()函数来判断。 # 获取缺失值数目 sum(is.na(bmi)) ## [1] 2 # 获取缺失值的索引值 which(is.na(bmi)) ## [1] 3 8 # 移除缺失值 bmi[!is.na(bmi)] ## [1] 26.5 22.4 25.5 31.0 27.0 20.0 19.4 23.0 30.0 # 移除缺失值，同时显示缺失值的索引值 na.omit(bmi) ## [1] 26.5 22.4 25.5 31.0 27.0 20.0 19.4 23.0 30.0 ## attr(,&quot;na.action&quot;) ## [1] 3 8 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; 在处理含有缺失值的向量时，很多函数在默认参数下不能工作。 # 有缺失值时，函数在默认参数下不能工作 mean(bmi) ## [1] NA # 移除缺失值之后计算均值 mean(bmi, na.rm=TRUE) ## [1] 24.97778 # 复制向量 bmi_impute &lt;- bmi # 对向量进行均值填补 bmi_impute[is.na(bmi_impute)] &lt;- mean(bmi_impute, na.rm=TRUE) # 填补只会作用于（复制后的）目标向量，对初始向量无影响 writeLines(paste0(&quot;填补后的目标向量为：&quot;, list(round(bmi_impute, 2)), &quot;\\n&quot;, &quot;填补后的初始向量为：&quot;, list(bmi))) ## 填补后的目标向量为：c(26.5, 22.4, 24.98, 25.5, 31, 27, 20, 24.98, 19.4, 23, 30) ## 填补后的初始向量为：c(26.5, 22.4, NA, 25.5, 31, 27, 20, NA, 19.4, 23, 30) 1.5 矩阵 矩阵(matrix)是m×n个数按照m行n列的方式排列形成的数表。R中的矩阵(matrix)可以通过matrix()函数、cbind()或rbind()函数生成。 matrix()函数用于将向量转变为m×n的矩阵，输入向量的长度必须等于m×n。 cbind()函数指column bind，即列的叠加，要求输入的向量或矩阵的行数相同。 rbind()函数指row bind，即行的叠加，要求输入的向量或矩阵的列数相同。 # 创建向量 var_vector &lt;- c(1,2,3,4,5,6) # matrix()函数生成矩阵 var_matrix &lt;- matrix(var_vector, nrow=2) var_matrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # 列叠加 cbind(var_matrix, var_matrix) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 1 3 5 ## [2,] 2 4 6 2 4 6 # 行叠加 rbind(var_matrix, var_matrix) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## [3,] 1 3 5 ## [4,] 2 4 6 矩阵的转置使用t()函数,t指transpose。 t(var_matrix) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 矩阵中元素的提取采用[行索引,列索引]的方式。 # 提取第1行第2列的元素 var_matrix[1,2] ## [1] 3 # 提取第1行第2、3列的元素 var_matrix[1,c(2,3)] ## [1] 3 5 # 提取第1行的所有元素 var_matrix[1,] ## [1] 1 3 5 # 提取第2列的所有元素 var_matrix[,2] ## [1] 3 4 采用dim()函数（dim指dimension）获取矩阵的维度，nrow()函数获取矩阵的行数，ncol()函数获取矩阵的列数。 # 获取维度 dim(var_matrix) ## [1] 2 3 # 获取行数 nrow(var_matrix) ## [1] 2 # 获取列数 ncol(var_matrix) ## [1] 3 1.6 数据框 矩阵只能包含一个种类的数据。 cbind(c(&quot;M&quot;,&quot;F&quot;), var_matrix) ## [,1] [,2] [,3] [,4] ## [1,] &quot;M&quot; &quot;1&quot; &quot;3&quot; &quot;5&quot; ## [2,] &quot;F&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; 如上所示，当加入字符型数据后，矩阵中的数字也被强制转变为字符型（即被双引号包裹），这被称为隐式强制。因此，使用数据框(dataframe)可以存储不同类型的数据，保留原有数据的完整性。 # 调用R自带iris数据框 data(iris) # 查看数据类型 class(iris) ## [1] &quot;data.frame&quot; # 查看数据框维度 dim(iris) ## [1] 150 5 # 查看数据框内的变量类型 str(iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 1.7 数组 数组（array）是矩阵的扩展，可以将矩阵扩展至2维以上。1维数组相当于向量1.3，2维数组相当于矩阵1.5。R中使用array()函数创建数组，主要的参数为： X输入数据，可以是向量或者矩阵。 dim输出维度，如果输出多维度，使用c(m,n,k,..)，其中m×n为最内层矩阵。 # 创建3×6维的数组 var_array1 &lt;- array(seq(1:18), dim=c(3,6)) var_array1 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 4 7 10 13 16 ## [2,] 2 5 8 11 14 17 ## [3,] 3 6 9 12 15 18 # 创建3×2×3维的数组 var_array2 &lt;- array(seq(1:18), dim=c(3,2,3)) var_array2 ## , , 1 ## ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 ## ## , , 2 ## ## [,1] [,2] ## [1,] 7 10 ## [2,] 8 11 ## [3,] 9 12 ## ## , , 3 ## ## [,1] [,2] ## [1,] 13 16 ## [2,] 14 17 ## [3,] 15 18 # 获取第3层的矩阵 var_array2[,,3] ## [,1] [,2] ## [1,] 13 16 ## [2,] 14 17 ## [3,] 15 18 1.8 列表 列表（list）是R语言的对象集合，可以用来保存不同类型的数据，使用list()函数创建。与c()函数1.3不同，list()函数保留输入数据最初的数据结构，而c()函数将所有输入数据降维放入一个向量中。使用unlist()函数可以将列表转变为向量。 test_list &lt;- list(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), 23, matrix(c(1,2,3,4),nrow=2)) length(test_list) ## [1] 3 test_vector &lt;- c(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), 23, matrix(c(1,2,3,4),nrow=2)) length(test_vector) ## [1] 8 length(unlist(test_list)) # 使用`unlist()`函数将列表转变为向量 ## [1] 8 在获取列表元素时，如果采用[]+索引值的方式，返回的结果为包含该元素的列表。如果需要将列表元素提取为向量，则需采用[[]]+索引值的方式。如果列表的元素有名称，可以采用$或[[]]+名称的方式调用。 向列表添加元素可以使用append()函数。 注意：如果需要将整个向量添加进原有列表中，必须先将向量转为列表形式，否则R会将向量中的元素逐个添加为列表的元素。 # 使用[[]]获取列表中的元素 test_list[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 如果列表的元素有名称，可以采用`$`调用 # 给列表的元素命名 names(test_list) &lt;- c(&quot;vec&quot;, &quot;n&quot;, &quot;mtx&quot;) # 使用&quot;$+名称&quot;调用列表元素 test_list$vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 使用&quot;[[名称]]&quot;调用列表元素 test_list[[&quot;vec&quot;]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 整个添加向量 append(test_list, list(c(FALSE, FALSE, TRUE))) ## $vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $n ## [1] 23 ## ## $mtx ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## [[4]] ## [1] FALSE FALSE TRUE # 逐个添加向量元素 append(test_list, c(FALSE, FALSE, TRUE)) ## $vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $n ## [1] 23 ## ## $mtx ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 ## ## [[4]] ## [1] FALSE ## ## [[5]] ## [1] FALSE ## ## [[6]] ## [1] TRUE 1.9 字符串处理 在处理数据过程中，通常会碰到需要提取具有某一类特征的变量名或者需要从特定变量中筛选出包含某一类特征的字符串的情况。正则表达式（regular expression）就是帮助我们识别特定字符串的工具。 R中可以使用grep函数、grepl函数或者调用stringr包的str_view函数进行正则表达式匹配： grep函数返回目标字符串所在的位置（即索引值）。 grepl函数返回逻辑向量。 stringr包的str_view函数返回目标字符串，str_detect函数返回逻辑向量。 正则表达式主要依赖于元字符，其具体含义如下表： 元字符 含义 [] 匹配方括号内的任意字符（可以任意组合） [^] 匹配除方括号内字符以外的任意字符 * 匹配大于等于0个在*号之前的重复字符 + 匹配至少1个在+号之前的重复字符 ? 匹配至多1个在+号之前的重复字符 {n} 匹配正好n个在{}号之前的字符 {n,} 匹配至少n个在{}号之前的字符 {n,m} 匹配至少n个，至多m个在{}号之前的字符 () 匹配与括号内完全相同的字符（数目与排序必须完全一致） | 匹配|符号前或后的字符 ^ ^之后的字符位于开始端 $ $之前的字匹配字符位于末端 \\ 转义字符，用于匹配保留的元字符 .[]*+?{}()\\^$ 正则表达式也提供一些常用的字符集简写，如下表所示： 简写 含义 . 除换行符外的所有字符 \\d 匹配所有数字，等同于[0-9] \\D 匹配所有非数字，等同于[^0-9] \\w 匹配所有字母、数字和下划线，等同于[a-zA-Z0-9_] \\W 匹配所有非字母、数字和下划线，等同于[^a-zA-Z0-9_] \\t 匹配水平制表符 \\n 匹配换行符 \\s 匹配所有空格字符（空格、制表符或换行符） \\S 匹配所有非空格字符（空格、制表符或换符行） 注意： 在R中使用正则表达式时，字符型常量中一个\\要写成两个\\\\。 使用字符集简写时，grep函数的perl参数需要被设定成TRUE。 # 创建字符串向量 var_name &lt;- c(&quot;cn-Bmi_2014&quot;, &quot;cn_-bMi-2015&quot;, &quot;uk-bmi_2014&quot;, &quot;uk-bm i_2015&quot;, &quot;ck_bmi_2014&quot;, &quot;ck_bmi_2015&quot;, &quot;cn_bim_2014&quot;, &quot;uk_bim_2014&quot;, &quot;ck_b im_2014&quot;) # 查找包含BMI的变量 var_name[grep(&quot;bmi|bm i&quot;, var_name, ignore.case=TRUE)] ## [1] &quot;cn-Bmi_2014&quot; &quot;cn_-bMi-2015&quot; &quot;uk-bmi_2014&quot; &quot;uk-bm i_2015&quot; &quot;ck_bmi_2014&quot; ## [6] &quot;ck_bmi_2015&quot; # 查找cn和uk的BMI变量 var_name[grep(&quot;^(cn|uk)[\\\\w-]+bmi&quot;, var_name, ignore.case=TRUE, perl=TRUE)] ## [1] &quot;cn-Bmi_2014&quot; &quot;cn_-bMi-2015&quot; &quot;uk-bmi_2014&quot; # 查找ck 2014年的变量 var_name[grep(&quot;^ck[\\\\w\\\\s-]+2014$&quot;, var_name, ignore.case=TRUE, perl=TRUE)] ## [1] &quot;ck_bmi_2014&quot; &quot;ck_b im_2014&quot; # 调用包 library(stringr) str_view(var_name, &quot;bmi&quot;) # 大小写敏感 ## [3] │ uk-&lt;bmi&gt;_2014 ## [5] │ ck_&lt;bmi&gt;_2014 ## [6] │ ck_&lt;bmi&gt;_2015 # 默认大小写敏感，如果想忽略大小写，需要用regex(ignore_case=TRUE)说明 str_view(var_name, regex(&quot;bmi&quot;, ignore_case=TRUE)) ## [1] │ cn-&lt;Bmi&gt;_2014 ## [2] │ cn_-&lt;bMi&gt;-2015 ## [3] │ uk-&lt;bmi&gt;_2014 ## [5] │ ck_&lt;bmi&gt;_2014 ## [6] │ ck_&lt;bmi&gt;_2015 有时我们也会碰到在字符串的前后有空格的情况，这时我们可以用[\\\\s]*去进行正则表达式匹配或者使用stringr包的str_trim()函数移除位于字符串两端的空格。如果需要移除字符串中间的多余空格（即仅保留一个空格），可以使用str_squish()函数。 library(stringr) trim_vector &lt;- c(&quot; the &quot;, &quot; good&quot;, &quot;b ad &quot;) str_trim(trim_vector) ## [1] &quot;the&quot; &quot;good&quot; &quot;b ad&quot; trim_string &lt;- &quot; Marry has a little lamb. &quot; str_squish(trim_vector) # 字符串中间仅保留一个空格 ## [1] &quot;the&quot; &quot;good&quot; &quot;b ad&quot; str_squish(trim_string) ## [1] &quot;Marry has a little lamb.&quot; 1.10 常用函数 1.10.1 seq()函数 seq()函数用于生成一组数字序列，seq代表sequence。参数包括： from数字序列起点，默认为1。 to数字序列终点。 by步长，可以为正数、负数或者小数。 length.out生成数字序列的长度。 along.with生成与目标序列相同长度的数字序列。 # 从0开始，在[0,6]范围内生成以3为步长的数字序列 seq(from=0, to=6, by=3) ## [1] 0 3 6 # 超出范围的数字将不会被纳入到数字序列中 seq(from=1, to=6, by=3) ## [1] 1 4 # 从0开始，以3为步长，生成一个包含4个元素的数字序列 seq(from=0, by=3, length.out=4) ## [1] 0 3 6 9 # 从1开始，以2为步长，生成一个与month.abb相同长度的数字序列 seq(from=1, by=2, along.with=month.abb) ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 1.10.2 rep()函数 rep()函数用于生成重复序列，rep代表repeat。参数包括： x想要进行复制的对象，可以是一个数字，字符或者向量。 times对整个目标对象复制的次数，只能为正整数。 each对目标对象内元素复制的次数，只能为正整数。 length.out生成序列的长度。 # 对向量c(1,2,3)复制2次 rep(1:3, times=3) ## [1] 1 2 3 1 2 3 1 2 3 # 对向量c(1,2,3)内的元素分别复制3、2、1次 rep(1:3, times=c(3,2,1)) ## [1] 1 1 1 2 2 3 # 对向量c(1,2,3)内的元素各复制2次 rep(1:3, each=2) ## [1] 1 1 2 2 3 3 # 超过的长度自动截断 rep(c(&quot;abc&quot;, &quot;bbb&quot;), time=3, length.out=3) ## [1] &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; # 不足的长度自动填补 rep(c(&quot;abc&quot;, &quot;bbb&quot;), time=3, length.out=9) ## [1] &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; &quot;bbb&quot; &quot;abc&quot; 1.10.3 unique()函数 unique()函数用于移除重复值。 unique(c(1,2,2,3,4,3,2)) ## [1] 1 2 3 4 1.10.4 quantile()函数 quantile()函数用于获取分位数。 # 获取上下四分位数以及中位数 quantile(seq(0,1,0.05), probs=c(0.25,0.5,0.75)) ## 25% 50% 75% ## 0.25 0.50 0.75 1.10.5 floor()、ceiling()、round()函数 有时我们需要对小数进行处理。 floor()函数返回不大于当前数字的最大整数，实际操作为提取数字的整数部分。 ceiling()函数返回不小于于当前数字的最小整数，实际操作为提取数字的整数部分再加1。 round()函数用于四舍五入至特定小数位。 num_demo &lt;- 3.1415926 floor(num_demo) ## [1] 3 ceiling(num_demo) ## [1] 4 round(num_demo, 3) ## [1] 3.142 1.10.6 sample()函数 sample()函数用于随机抽样。参数包括： x想要进行抽样的向量。 size想要进行抽样的向量。 replace默认为FALSE，即不重复抽样，此时size不能大于x。若为TRUE，则为重复抽样，此时size可以大于x。 prob向量中各元素被抽到的概率，默认为NULL，即概率相同。 注意：在进行随机抽样前，使用 set.seed() 函数设置随机种子可以保证抽样结果的复现。随机种子的赋值只需初始化一次。 # set.seed(1) sample(1:6, size=10, replace=TRUE) # 从[1,6]中重复地随机抽取10个元素 ## [1] 1 1 6 5 5 2 2 6 1 4 1.10.7 combn()函数 combn()函数用于获得目标向量中指定长度的所有组合，常用于需要遍历变量组合的情况。参数包括： x目标向量。 m指定组合长度。 simplify默认为TRUE，即返回矩阵。若为FALSE，则返回列表。 # 创建向量 var_list &lt;- c(&quot;bmi&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;education&quot;) # 将var_list内的三个元素随机组合，返回为矩阵 combn(var_list, 3) ## [,1] [,2] [,3] [,4] ## [1,] &quot;bmi&quot; &quot;bmi&quot; &quot;bmi&quot; &quot;age&quot; ## [2,] &quot;age&quot; &quot;age&quot; &quot;sex&quot; &quot;sex&quot; ## [3,] &quot;sex&quot; &quot;education&quot; &quot;education&quot; &quot;education&quot; # 获取返回矩阵的第一个组合 combn(var_list, 3)[,1] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; # 将变量var_list内的三个元素随机组合，返回为列表 combn(var_list, 3, simplify=FALSE) ## [[1]] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; ## ## [[2]] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;education&quot; ## ## [[3]] ## [1] &quot;bmi&quot; &quot;sex&quot; &quot;education&quot; ## ## [[4]] ## [1] &quot;age&quot; &quot;sex&quot; &quot;education&quot; # 获取返回列表的第一个组合 combn(var_list, 3, simplify=FALSE)[[1]] ## [1] &quot;bmi&quot; &quot;age&quot; &quot;sex&quot; 1.10.8 paste()函数 paste()函数用于将向量、数字或字符合并成字符串，常用于特定语句的生成。 sep参数用于定义将不同向量或字符合并成字符串所用的连接符。 collapse参数用于定义将单一向量内元素合并成字符串所用的连接符。 # 将不同向量或字符合并成字符串 paste(&quot;are&quot;, &quot;you&quot;, &quot;OK&quot;, sep=&quot; &quot;) # 返回一个字符串 ## [1] &quot;are you OK&quot; paste0(&quot;are&quot;, &quot;you&quot;, &quot;OK&quot;) # paste0()与paste(sep=&quot;&quot;)一样 ## [1] &quot;areyouOK&quot; paste(var_list, &quot;cn&quot;, sep=&quot;-&quot;) # 返回包含字符串的向量 ## [1] &quot;bmi-cn&quot; &quot;age-cn&quot; &quot;sex-cn&quot; &quot;education-cn&quot; # 将单一向量内元素合并成字符串 paste(var_list, collapse=&quot;+&quot;) # 返回一个字符串 ## [1] &quot;bmi+age+sex+education&quot; 1.10.9 ifelse()函数 ifelse()函数为条件函数，包含三个参数： test条件。 yes条件为TRUE时的返回值。 no条件为FALSE时的返回值。 此函数在条件判断中可以得到多个逻辑结果，返回对应数目的逻辑值并根据逻辑值赋值（注意与if(){}else{}函数1.10.10的区别）。此函数可以嵌套。 # 创建向量 age &lt;- seq(1,4) target &lt;- c(2,2,4,4) # ifelse可进行多个逻辑判断并分别返回值 ifelse(age==target, &quot;Y&quot;, &quot;N&quot;) ## [1] &quot;N&quot; &quot;Y&quot; &quot;N&quot; &quot;Y&quot; ifelse(age==1, &quot;age1&quot;, ifelse(age&lt;4, &quot;age2&quot;, &quot;age3&quot;)) ## [1] &quot;age1&quot; &quot;age2&quot; &quot;age2&quot; &quot;age3&quot; 1.10.10 if(){}else{}函数 ()内为判断条件，如果为真，则运行第一个{}的指令，否则运行第二个{}的指令。此判断条件中只接受一个逻辑结果。如果输入多个逻辑结果，将会报错，此时需要用any()或者all()函数对多个逻辑结果进行处理。使用多个else if(){}进行嵌套。 注意与ifelse()函数1.10.9的区别。 # if(){}else{}只接受一个逻辑值 if(any(age==c(1,1,1,1))){&quot;Y&quot;} else{&quot;N&quot;} ## [1] &quot;Y&quot; # 创建向量 new_age &lt;- 55 if(new_age&lt;40){ &quot;青年&quot; } else if(new_age&lt;60){ &quot;中年&quot; } else {&quot;老年&quot;} ## [1] &quot;中年&quot; 1.10.11 循环 1.10.11.1 for循环 for循环是R语言中最常用的迭代函数之一，形式为for(){}： ()内为迭代器，即需要迭代的向量。 {}内为想要运行的指令。 for(i in seq(1:4)){ print(paste0(&quot;现在的数字是：&quot;, i)) # 循环打印 } ## [1] &quot;现在的数字是：1&quot; ## [1] &quot;现在的数字是：2&quot; ## [1] &quot;现在的数字是：3&quot; ## [1] &quot;现在的数字是：4&quot; ini_num &lt;- 5 # 设定初始值 sum_container &lt;- c() # 创建空向量 for(i in seq(1,5,by=2)){ ini_num = ini_num + i # 迭代求和 sum_container &lt;- append(sum_container, ini_num) # 将求和值添加入向量 } sum_container ## [1] 6 9 14 1.10.11.2 while循环 while(){}循环将重复执行{}中的指令直至不能满足()中的条件。 init_num &lt;- 0 # 设定初始值 while(init_num&lt;4){ init_num = init_num + 1 # 每次计数+1 print(paste0(&quot;已完成&quot;, init_num, &quot;次运算。&quot;)) } ## [1] &quot;已完成1次运算。&quot; ## [1] &quot;已完成2次运算。&quot; ## [1] &quot;已完成3次运算。&quot; ## [1] &quot;已完成4次运算。&quot; 1.10.11.3 apply()函数 当需要对矩阵或者数据框进行统一的特定处理时，为避免重复使用循环，可以选择apply()函数，返回类型为向量或矩阵。此函数中三个主要的参数为： X输入数据。 MARGIN指令执行方向。 FUN执行指令。 FUN MARGIN 指令执行说明 当指令需要作用于多个元素 MARGIN=1 逐行运行指令，返回向量 当指令需要作用于多个元素 MARGIN=2 逐列运行指令，返回向量 当指令只作用于单个元素 MARGIN=1 逐个运行指令，返回矩阵。可以理解为将数据转置后对单个元素进行处理。 当指令只作用于单个元素 MARGIN=2 逐个运行指令，返回矩阵。可以理解为在原有数据上直接对单个元素进行处理。 # apply()函数与矩阵 var_matrix &lt;- matrix(c(1,4,9,16,25,36),nrow=2) # 指令作用于多个元素 apply(var_matrix, 1, sum) ## [1] 35 56 # 指令作用于多个元素 apply(var_matrix, 2, sum) ## [1] 5 25 61 # 指令作用于单个元素 apply(var_matrix, 1, sqrt) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 # 指令作用于单个元素 apply(var_matrix, 2, sqrt) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 # apply()函数与数据框 # 读取数据 data(iris) # 对iris数据库中的第1、3列分别求和 apply(iris[,c(1,3)], 2, sum) ## Sepal.Length Petal.Length ## 876.5 563.7 当需要对列表或数据框进行统一的特定处理时，可以使用lapply()函数，返回类型为列表。主要参数为X即输入数据和FUN执行指令。当FUN作用于X内的单个元素时，X的结构不会发生改变。 var_vector_list &lt;- list(c(1,4,9), c(16,25,36)) lapply(var_vector_list, sum) ## [[1]] ## [1] 14 ## ## [[2]] ## [1] 77 # 函数作用于单个元素时，元素结构不会发生改变 lapply(var_vector_list, sqrt) ## [[1]] ## [1] 1 2 3 ## ## [[2]] ## [1] 4 5 6 var_matrix_list &lt;- list(matrix(c(1,4,9,16,25,36),nrow=2),matrix(c(1,4,9,16,25,36),nrow=2)) lapply(var_matrix_list, sum) ## [[1]] ## [1] 91 ## ## [[2]] ## [1] 91 # 函数作用于单个元素时，元素结构不会发生改变 lapply(var_matrix_list, sqrt) ## [[1]] ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## [[2]] ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 当需要对列表、向量或数据框进行统一的特定处理且希望返回最简单的数据结构时，可以使用sapply()函数。 var_matrix &lt;- matrix(c(1,4,9,16,25,36),nrow=2) sapply(var_matrix, sum) # 返回向量 ## [1] 1 4 9 16 25 36 sapply(var_matrix, sqrt) # 返回向量 ## [1] 1 2 3 4 5 6 var_vector_list &lt;- list(c(1,4,9), c(16,25,36)) sapply(var_vector_list, sum) # 返回向量 ## [1] 14 77 sapply(var_vector_list, sqrt) # 返回矩阵 ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 var_matrix_list &lt;- list(matrix(c(1,4,9,16,25,36),nrow=2),matrix(c(1,4,9,16,25,36),nrow=2)) sapply(var_vector_list, sum) # 返回向量 ## [1] 14 77 sapply(var_matrix_list, sqrt) # 返回矩阵 ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 ## [3,] 3 3 ## [4,] 4 4 ## [5,] 5 5 ## [6,] 6 6 当需要对向量按类别进行统一的特定处理时，可以使用tapply()函数，返回数组。 data(iris) tapply(iris[,1], iris$Species, mean) ## setosa versicolor virginica ## 5.006 5.936 6.588 小结 函数 主要参数 输入数据类型 输出数据类型 apply apply(X,MARGIN,FUN) 矩阵、数据框 向量、矩阵 lapply lapply(X,FUN) 列表、数据框 列表 sapply sapply(X,FUN) 列表、矩阵、数据框 向量、矩阵 tapply tapply(X,INDEX,FUN) 向量 数组 1.10.12 自定义函数 function(){}用于自定义函数，其中()用于定义函数的参数，{}用于定义函数的指令并以return()定义要返回的数据。 # 定义一个函数，用于报告向量长度 length_report &lt;- function(x){ print(paste0(&quot;此向量的长度是：&quot;, length(x))) } length_report(c(&quot;bmi&quot;, &quot;grip&quot;, &quot;sex&quot;, &quot;age&quot;)) ## [1] &quot;此向量的长度是：4&quot; # 定义一个x+2y的函数，返回运算结果 multiply_function &lt;- function(x,y){ return(x+2*y) } result_multiply &lt;- multiply_function(2,3) # 传入参数位置与函数参数位置对应 result_multiply ## [1] 8 # 定义默认变量 multiply_function2 &lt;- function(x,y,z=&quot;运算完成！&quot;){ print(z) return(x+2*y) } multiply_function2(2,3) ## [1] &quot;运算完成！&quot; ## [1] 8 multiply_function2(2,3,&quot;哈哈，运算完成~&quot;) ## [1] &quot;哈哈，运算完成~&quot; ## [1] 8 函数只能返回一个结果，所以，如果有多个结果需要返回时，可以将结果整合为向量、列表或者数据框的形式之后再返回。 # 定义一个函数，获取向量内个元素累计叠加的值 accumulation &lt;- function(x){ init_num &lt;- x[1] # 获取第1个元素 result &lt;- c(init_num) # 建立result向量收集结果 if (length(x)&gt;=2){ for(i in seq(2,length(x))) { init_num &lt;- init_num + x[i] result &lt;- append(result, init_num) } } return(result) # 返回向量 } accumulation(c(1)) ## [1] 1 accumulation(seq(1:4)) ## [1] 1 3 6 10 # 方法2：使用while循环 accumulation2 &lt;- function(x){ init_num &lt;- x[1] vec_length &lt;- length(x) result &lt;- c(init_num) while(vec_length&gt;1){ vec_length &lt;- vec_length - 1 init_num &lt;- init_num + x[length(x)-vec_length+1] result &lt;- append(result, init_num) } return(result) } accumulation2(c(1)) ## [1] 1 accumulation2(seq(1:4)) ## [1] 1 3 6 10 "],["数据导入导出与预处理.html", "第2章 数据导入、导出与预处理 2.1 数据导入 2.2 数据导出 2.3 路径 2.4 数据预处理", " 第2章 数据导入、导出与预处理 2.1 数据导入 2.1.1 CSV文件读取 CSV（comma-separated values）文件是以.csv结尾的文件，文件中的数据以,分隔，每一行代表一条记录。如 读取csv文件或者以类似格式存储数据的txt文件时，可以使用read.csv()函数。 注意：在输入文件路径时，需要使用\\\\或者/。 # 读取数据 wine_df &lt;- read.csv(&quot;data/wine.csv&quot;) # 或者 read.csv(&quot;data\\\\wine.csv&quot;) # 显示前5行记录 head(wine_df, 5) ## X1 X14.23 X1.71 X2.43 ## 1 1 13.20 1.78 2.14 ## 2 1 13.16 2.36 2.67 ## 3 1 14.37 1.95 2.50 ## 4 1 13.24 2.59 2.87 ## 5 1 14.20 1.76 2.45 在上例中可以看到，read.csv()默认将第一行记录读取为变量名。如果不将第一行读取为变量名 ，可以声明参数header=FALSE，这时，变量名将自动生成（“V1”,“V2”…）。 # 读取数据 wine_df &lt;- read.csv(&quot;data/wine.csv&quot;, header=FALSE) # 显示前5行记录 head(wine_df, 5) ## V1 V2 V3 V4 ## 1 1 14.23 1.71 2.43 ## 2 1 13.20 1.78 2.14 ## 3 1 13.16 2.36 2.67 ## 4 1 14.37 1.95 2.50 ## 5 1 13.24 2.59 2.87 有些文件中的数据会以,当做千位分隔符，数据以;分隔，这时可以用read.csv2()函数。 # 读取数据 revenue_df &lt;- read.csv2(&quot;data/revenue.txt&quot;) # 显示前5行记录 head(revenue_df, 5) ## company revenue other_income ## 1 A 10.114 2.102 ## 2 B 18.723 4.055 ## 3 C 20.266 6.314 ## 4 D 36.844 5.084 ## 5 E 59.711 9.430 2.1.2 excel文件读取 excel文件的读取可以使用readxl包的read_excel()函数。此函数默认读取第一个工作表，如果需要读取特定工作表，可以声明sheet变量。 # 加载包 library(readxl) # 读取数据 goods_df &lt;- read_excel(&quot;data/goods.xlsx&quot;) # 显示前5行记录 head(goods_df,5) ## # A tibble: 5 × 3 ## country continent amount ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 11 ## 2 Albania Europe 30 ## 3 Algeria Africa 49 ## 4 Andorra Europe 55 ## 5 Bahrain Asia 20 读取一个excel文件中的多个工作表。 # 返回&quot;goods.xlsx&quot;工作表名称 sheets &lt;- excel_sheets(&quot;data/goods.xlsx&quot;) # 读取每个工作表为数据框并返回列表 multi_df &lt;- lapply(sheets, function(x){read_excel(&quot;data/goods.xlsx&quot;, sheet=x)}) # 给列表的元素命名 names(multi_df) &lt;- sheets # 查看生成的列表长度（每个元素对应一个工作表） length(multi_df) ## [1] 5 # 显示Year2020工作表前5行记录 head(multi_df$Year2020,5) ## # A tibble: 5 × 3 ## country continent amount ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 11 ## 2 Albania Europe 30 ## 3 Algeria Africa 49 ## 4 Andorra Europe 55 ## 5 Bahrain Asia 20 2.1.3 文件读取汇总 文件类型 调用包 读取函数 CSV文件（*.csv） utils（R自带） read.csv() TXT文件（*.txt） utils（R自带） read.csv() excel文件（*.xlsx或*.xls） readxl read_excel() SAS文件（*.sas7bdat） haven read.sas() SPSS文件（*.sav） haven read.sav() STATA文件（*.dta） haven read_dta() 2.2 数据导出 数据导出类型 导出时调用包 导出函数 读取时调用包 读取函数 R数据文件（*.Rdata） base（R自带） save() base（R自带） load() CSV文件（*.csv） utils（R自带） write.csv() utils（R自带） read.csv() 自定义文件（*.csv或*.txt） utils（R自带） write.table() utils（R自带） read.csv() excel文件（*.xlsx） WriteXLS WriteXLS() readxl read_excel() # 将goods_df导出为goods.csv文件，导出位置为D盘 # row.names=FALSE时将不会导出数据索引值 # write.csv(goods_df, &quot;D:/goods.csv&quot;, row.names=FALSE) # 注意：此行代码在线上书中将不会执行 2.3 路径 我们在读取文件时，可以使用文件完整的存储路径，比如D:/a-quick-start-on-data-analysis-in-r/data/goods.xlsx，它能帮助我们找到任意位置上的文件，这条路径被称绝对路径（absolute directory）。 有时，文件的绝对路径很长，而且我们需要处理的文件一般都集中在特定文件夹下，这时，为了避免代码冗长，我们可以先设定一个工作路径，告诉R在查找文件时只查找存储在这个工作路径下的文件。这样，当我们要调用特定文件时，只需要调用该文件在当前工作路径下的路径，这条路径被称为相对路径（relative directory）。例如，当我们将D:/a-quick-start-on-data-analysis-in-r设置为工作路径，这时，如果要调用goods.xlsx，只需要输入路径data/goods.xlsx即可。 我们可以使用getwd()函数来获取当前的工作路径，使用setwd()设置新的工作路径。 注意： 在设置了工作路径后，数据或图片的存储与读取都会默认在该工作路径下进行。 需要读取存储在其它路径的数据时，需要使用绝对路径。 2.4 数据预处理 2.4.1 tidyverse包 tidyverse包是R中的一个功能强大的数据处理包大集合，包含readr、haven和readxl（数据读取与导出），tidyr（数据清洗），dplyr（数据整理），stringr（字符处理），ggplot2（数据可视化）等。 利用tidyverse包可以通过管道符%&gt;%（快捷键shift+ctrl+m）对数据进行链式操作，从而对数据连续处理。 2.4.2 批量读取数据 有时我们需要对特定文件夹下面的特定类型（或者特定名称）文件进行批量读取，这时可以通过list.files()+map_dfr()函数实现。 # 加载包 library(tidyverse) # 获取data文件夹下的所有txt文件名 txt_names &lt;- list.files(path=&quot;data&quot;, pattern=&quot;txt&quot;, full.names=TRUE) # 批量读取txt文件并存储为一个数据框 # 调用tidyverse的map_dfr()函数，由于获取的txt文件使用;分隔符，所以用read_csv2()函数读取每个文件 df_batch &lt;- map_dfr(txt_names, read_csv2) # 显示前5行记录 head(df_batch,5) ## # A tibble: 5 × 3 ## company revenue other_income ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 A 10.1 2.10 ## 2 B 18.7 4.06 ## 3 C 20.3 6.31 ## 4 D 36.8 5.08 ## 5 E 59.7 9.43 # 显示后5行记录 tail(df_batch,5) ## # A tibble: 5 × 3 ## company revenue other_income ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 D 36.8 5.08 ## 2 E 59.7 9.43 ## 3 F 72.0 10.9 ## 4 G 68.8 6.03 ## 5 H 66.4 7.92 注意： 读取的数据是垂直堆叠（vertical stack）。 读取数据的变量名如果一致，则数据会放在同一列；如果不一致，则会另外创建列变量。 2.4.3 数据合并 有时我们有多个数据框，包含了不同的变量数据，在进行数据预处理与分析之前，需要使用*_join()函数将它们合并为一个数据框。 数据的合并依照键（key）进行，合并方式： 内连接（inner_join）：保留两个数据键相同的记录并进行合并。 左连接（left_join）：保留左侧数据（X）的所有记录，右侧数据（Y）的键跟左侧数据相同的，才进行合并，左侧数据缺失值标记为NA。 右连接（right_join）：保留右侧数据（Y）的所有记录，左侧数据（X）的键跟右侧数据相同的，才进行合并，右侧数据缺失值标记为NA。 全连接（full_join）：保留两个数据中的所有记录并进行合并，缺失值标记为NA。 半连接（semi_join）：保留左侧数据（X）中与右侧数据（Y）的键相同的记录。 反连接（anti_join）：保留左侧数据（X）中与右侧数据（Y）的键不同的记录。 # 设置随机种子 set.seed(1) # 创建左侧数据框 df_left &lt;- data.frame( ID = seq(5), region = rep(c(&quot;South&quot;, &quot;North&quot;), times=c(3,2)), gender = rep(c(&quot;F&quot;,&quot;M&quot;), times=c(3,2)), value = rnorm(5) ) # 创建右侧数据框 df_right &lt;- data.frame( ID = seq(3,7), region = rep(&quot;South&quot;, times=5), sex = rep(c(&quot;M&quot;,&quot;F&quot;), times=c(3,2)), value = rnorm(5) ) # 单键合并 df_single_key_join &lt;- inner_join(df_left, df_right, by=&quot;ID&quot;) # 默认左右侧变量分别加&quot;.x&quot;和&quot;.y&quot;标注 df_single_key_join ## ID region.x gender value.x region.y sex value.y ## 1 3 South F -0.8356286 South M -0.8204684 ## 2 4 North M 1.5952808 South M 0.4874291 ## 3 5 North M 0.3295078 South M 0.7383247 # 多键合并 df_multi_key_join &lt;- inner_join(df_left, df_right, by=c(&quot;ID&quot;, &quot;region&quot;)) df_multi_key_join ## ID region gender value.x sex value.y ## 1 3 South F -0.8356286 M -0.8204684 当目标数据框的键名相同时，可以使用上述合并函数。当目标数据框的键名不同时，可以使用merge()函数并声明by.x和by.y参数达到数据合并的效果。 # 不同键名的多键合并 df_diff_key_join &lt;- merge(df_left, df_right, by.x=c(&quot;ID&quot;, &quot;gender&quot;), by.y=c(&quot;ID&quot;, &quot;sex&quot;)) df_diff_key_join ## ID gender region.x value.x region.y value.y ## 1 4 M North 1.5952808 South 0.4874291 ## 2 5 M North 0.3295078 South 0.7383247 # 内连接 df_inner_join &lt;- merge(df_left, df_right, by=&quot;ID&quot;) df_inner_join ## ID region.x gender value.x region.y sex value.y ## 1 3 South F -0.8356286 South M -0.8204684 ## 2 4 North M 1.5952808 South M 0.4874291 ## 3 5 North M 0.3295078 South M 0.7383247 # 左连接 df_left_join &lt;- merge(df_left, df_right, by=&quot;ID&quot;, all.x=TRUE) df_left_join ## ID region.x gender value.x region.y sex value.y ## 1 1 South F -0.6264538 &lt;NA&gt; &lt;NA&gt; NA ## 2 2 South F 0.1836433 &lt;NA&gt; &lt;NA&gt; NA ## 3 3 South F -0.8356286 South M -0.8204684 ## 4 4 North M 1.5952808 South M 0.4874291 ## 5 5 North M 0.3295078 South M 0.7383247 # 右连接 df_right_join &lt;- merge(df_left, df_right, by=&quot;ID&quot;, all.y=TRUE) df_right_join ## ID region.x gender value.x region.y sex value.y ## 1 3 South F -0.8356286 South M -0.8204684 ## 2 4 North M 1.5952808 South M 0.4874291 ## 3 5 North M 0.3295078 South M 0.7383247 ## 4 6 &lt;NA&gt; &lt;NA&gt; NA South F 0.5757814 ## 5 7 &lt;NA&gt; &lt;NA&gt; NA South F -0.3053884 # 全连接 df_full_join &lt;- merge(df_left, df_right, by=&quot;ID&quot;, all=TRUE) df_full_join ## ID region.x gender value.x region.y sex value.y ## 1 1 South F -0.6264538 &lt;NA&gt; &lt;NA&gt; NA ## 2 2 South F 0.1836433 &lt;NA&gt; &lt;NA&gt; NA ## 3 3 South F -0.8356286 South M -0.8204684 ## 4 4 North M 1.5952808 South M 0.4874291 ## 5 5 North M 0.3295078 South M 0.7383247 ## 6 6 &lt;NA&gt; &lt;NA&gt; NA South F 0.5757814 ## 7 7 &lt;NA&gt; &lt;NA&gt; NA South F -0.3053884 当有多个数据框需要合并时，可以先将数据框放入一个列表中，再使用reduce()函数合并。 # 将数据框放入列表中 df_list &lt;- list(df_diff_key_join, df_inner_join, df_left_join, df_right_join) # 多数据框合并 df_list_join &lt;- df_list %&gt;% reduce(inner_join, by=&quot;ID&quot;) df_list_join ## ID gender.x region.x.x value.x.x region.y.x value.y.x region.x.y gender.y value.x.y ## 1 4 M North 1.5952808 South 0.4874291 North M 1.5952808 ## 2 5 M North 0.3295078 South 0.7383247 North M 0.3295078 ## region.y.y sex.x value.y.y region.x.x.x gender.x.x value.x.x.x region.y.x.x sex.y ## 1 South M 0.4874291 North M 1.5952808 South M ## 2 South M 0.7383247 North M 0.3295078 South M ## value.y.x.x region.x.y.y gender.y.y value.x.y.y region.y.y.y sex value.y.y.y ## 1 0.4874291 North M 1.5952808 South M 0.4874291 ## 2 0.7383247 North M 0.3295078 South M 0.7383247 2.4.4 数据清洗 数据清洗是数据预处理的第一步，包括变量选择，变量重命名，缺失值处理，重复值删除等。 2.4.4.1 变量选择 变量的选择可以使用select()函数，()内直接填写变量名称或者变量的索引值。详细介绍参考此链接。 # 读取数据 df_darwin &lt;- read_csv(&quot;data/darwin.csv&quot;) # 选取 air_time1 和 gender 变量 df_darwin %&gt;% select(air_time1, gender) %&gt;% head() ## # A tibble: 6 × 2 ## air_time1 gender ## &lt;dbl&gt; &lt;chr&gt; ## 1 5160 M ## 2 51980 M ## 3 2600 M ## 4 2130 F ## 5 2310 F ## 6 1920 F # 选取除 air_time1 和 gender 之外的所有变量 df_darwin %&gt;% select(!c(air_time1, gender)) %&gt;% head() ## # A tibble: 6 × 32 ## ID gmrt_in_air1 max_x_extension1 max_y_extension1 mean_acc_in_air1 mean_gmrt1 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 id_1 121. 957 6601 0.362 104. ## 2 id_2 115. 1694 6998 0.273 99.4 ## 3 id_3 230. 2333 5802 0.387 201. ## 4 id_4 369. 1756 8159 0.557 276. ## 5 id_5 258. 987 4732 0.266 185. ## 6 id_6 200. 1548 6260 0.213 155. ## # ℹ 26 more variables: air_time2 &lt;dbl&gt;, gmrt_in_air2 &lt;dbl&gt;, max_x_extension2 &lt;dbl&gt;, ## # max_y_extension2 &lt;dbl&gt;, mean_acc_in_air2 &lt;dbl&gt;, mean_gmrt2 &lt;dbl&gt;, air_time3 &lt;dbl&gt;, ## # gmrt_in_air3 &lt;dbl&gt;, max_x_extension3 &lt;dbl&gt;, max_y_extension3 &lt;dbl&gt;, ## # mean_acc_in_air3 &lt;dbl&gt;, mean_gmrt3 &lt;dbl&gt;, air_time4 &lt;dbl&gt;, gmrt_in_air4 &lt;dbl&gt;, ## # max_x_extension4 &lt;dbl&gt;, max_y_extension4 &lt;dbl&gt;, mean_acc_in_air4 &lt;dbl&gt;, ## # mean_gmrt4 &lt;dbl&gt;, air_time5 &lt;dbl&gt;, gmrt_in_air5 &lt;dbl&gt;, max_x_extension5 &lt;dbl&gt;, ## # max_y_extension5 &lt;dbl&gt;, mean_acc_in_air5 &lt;dbl&gt;, mean_gmrt5 &lt;dbl&gt;, class &lt;chr&gt;, … 使用starts_with()选取以特定字符开头的变量。 # 选取以 air 或 max 开头的变量 df_darwin %&gt;% select(starts_with(c(&quot;air&quot;, &quot;max&quot;))) %&gt;% head() ## # A tibble: 6 × 15 ## air_time1 air_time2 air_time3 air_time4 air_time5 max_x_extension1 max_y_extension1 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5160 6085 4345 30625 66034 957 6601 ## 2 51980 10515 15885 7975 12875 1694 6998 ## 3 2600 560 420 1030 680 2333 5802 ## 4 2130 13735 3795 13625 10735 1756 8159 ## 5 2310 4225 2255 100650 1050 987 4732 ## 6 1920 8115 2620 3065 2400 1548 6260 ## # ℹ 8 more variables: max_x_extension2 &lt;dbl&gt;, max_y_extension2 &lt;dbl&gt;, ## # max_x_extension3 &lt;dbl&gt;, max_y_extension3 &lt;dbl&gt;, max_x_extension4 &lt;dbl&gt;, ## # max_y_extension4 &lt;dbl&gt;, max_x_extension5 &lt;dbl&gt;, max_y_extension5 &lt;dbl&gt; 使用match()选取符合特定正则表达式的变量。 # 选取名称中包含 extension4 和 extension5 的变量 df_darwin %&gt;% select(matches(&quot;extension[45]&quot;)) %&gt;% head() ## # A tibble: 6 × 4 ## max_x_extension4 max_y_extension4 max_x_extension5 max_y_extension5 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4353 4292 10933 3651 ## 2 7718 8055 5667 5503 ## 3 3960 4013 2556 2245 ## 4 4487 4475 2535 2426 ## 5 4429 4196 2394 1194 ## 6 4184 4379 2486 2447 使用num_range()选取以特定范围的数字结尾的变量。注意，数字的前缀必须为完整的变量名。 # 选取名称中 max_x_extension3、max_x_extension4 和 max_x_extension5 的变量 df_darwin %&gt;% select(num_range(&quot;max_x_extension&quot;, 3:5)) %&gt;% head() ## # A tibble: 6 × 3 ## max_x_extension3 max_x_extension4 max_x_extension5 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4495 4353 10933 ## 2 4498 7718 5667 ## 3 4645 3960 2556 ## 4 4568 4487 2535 ## 5 4076 4429 2394 ## 6 4075 4184 2486 2.4.4.2 变量重命名 变量的重命名可以使用rename()函数，()内填写新名称=旧名称。 # 将 gender 重命名为 sex df_darwin %&gt;% select(air_time1, gender) %&gt;% rename(sex=gender) %&gt;% head() ## # A tibble: 6 × 2 ## air_time1 sex ## &lt;dbl&gt; &lt;chr&gt; ## 1 5160 M ## 2 51980 M ## 3 2600 M ## 4 2130 F ## 5 2310 F ## 6 1920 F 2.4.4.3 缺失值处理 在进行缺失值处理前，我们需要了解各个变量的缺失值情况。 # 读取数据 df_miss &lt;- read_csv(&quot;data/darwin-missing.csv&quot;) # 获取各变量的缺失数 apply(df_miss, 2, function(x) {sum(is.na(x))}) ## ID air_time1 gmrt_in_air1 max_x_extension1 gender ## 0 2 1 4 2 通常而言，对于缺失比例大于20%的变量，我们倾向于将该变量剔除。 # 获取各变量的缺失数 col_miss_count &lt;- apply(df_miss, 2, function(x) {sum(is.na(x))}) # 保留缺失占比不超过20%的变量 df_miss_col &lt;- df_miss[, col_miss_count/nrow(df_miss) &lt;= 0.2] 对于有缺失值的记录，我们可以删除或者进行缺失值填补。 仅对所有变量均缺失的记录进行删除。 # 除去第一个ID变量，其余变量都有缺失的记录将被删除 df_miss_col %&gt;% filter(if_any(c(2:ncol(df_miss_col)), ~!is.na(.))) ## # A tibble: 9 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_3 2600 230. M ## 3 id_4 2130 369. F ## 4 id_5 NA 258. F ## 5 id_6 1920 200. F ## 6 id_7 6415 277. F ## 7 id_8 1510 284. F ## 8 id_9 4860 237. M ## 9 id_10 6265 382. &lt;NA&gt; 对任意变量有缺失的记录进行删除。 # 除去第一个ID变量，任意变量中有缺失的记录将被删除 df_miss_col %&gt;% filter(if_all(c(2:ncol(df_miss_col)), ~!is.na(.x))) ## # A tibble: 7 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_3 2600 230. M ## 3 id_4 2130 369. F ## 4 id_6 1920 200. F ## 5 id_7 6415 277. F ## 6 id_8 1510 284. F ## 7 id_9 4860 237. M # 任意变量中有缺失的记录将被删除 df_miss_col %&gt;% drop_na() ## # A tibble: 7 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_3 2600 230. M ## 3 id_4 2130 369. F ## 4 id_6 1920 200. F ## 5 id_7 6415 277. F ## 6 id_8 1510 284. F ## 7 id_9 4860 237. M 对特定变量有缺失的记录进行删除。 # gender变量中有缺失的记录将被删除 df_miss_col %&gt;% filter(!is.na(gender)) ## # A tibble: 8 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_3 2600 230. M ## 3 id_4 2130 369. F ## 4 id_5 NA 258. F ## 5 id_6 1920 200. F ## 6 id_7 6415 277. F ## 7 id_8 1510 284. F ## 8 id_9 4860 237. M 使用均值填补缺失值。 # 获取均值以便比较 mean(df_miss_col$air_time1, na.rm=TRUE) # 3857.5 ## [1] 3857.5 mean(df_miss_col$gmrt_in_air1, na.rm=TRUE) # 261.9154 ## [1] 261.9154 # 对连续型变量进行填补 df_miss_col %&gt;% mutate_if(is.double, ~replace_na(.x, mean(.x, na.rm=TRUE))) ## # A tibble: 10 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_2 3858. 262. &lt;NA&gt; ## 3 id_3 2600 230. M ## 4 id_4 2130 369. F ## 5 id_5 3858. 258. F ## 6 id_6 1920 200. F ## 7 id_7 6415 277. F ## 8 id_8 1510 284. F ## 9 id_9 4860 237. M ## 10 id_10 6265 382. &lt;NA&gt; # 第二种写法，将`~`替换成function(){}形式 df_miss_col %&gt;% mutate_if(is.double, function(x){replace_na(x, mean(x, na.rm=TRUE))}) ## # A tibble: 10 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_2 3858. 262. &lt;NA&gt; ## 3 id_3 2600 230. M ## 4 id_4 2130 369. F ## 5 id_5 3858. 258. F ## 6 id_6 1920 200. F ## 7 id_7 6415 277. F ## 8 id_8 1510 284. F ## 9 id_9 4860 237. M ## 10 id_10 6265 382. &lt;NA&gt; # 第三种写法，直接列举变量名 df_miss_col %&gt;% mutate_at(c(&quot;air_time1&quot;,&quot;gmrt_in_air1&quot;), function(x) {replace(x, is.na(x), mean(x, na.rm = TRUE))}) ## # A tibble: 10 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_2 3858. 262. &lt;NA&gt; ## 3 id_3 2600 230. M ## 4 id_4 2130 369. F ## 5 id_5 3858. 258. F ## 6 id_6 1920 200. F ## 7 id_7 6415 277. F ## 8 id_8 1510 284. F ## 9 id_9 4860 237. M ## 10 id_10 6265 382. &lt;NA&gt; 使用中位数填补缺失值。 # 获取中位数以便比较 median(df_miss_col$air_time1, na.rm=TRUE) # 3730 ## [1] 3730 median(df_miss_col$gmrt_in_air1, na.rm=TRUE) # 257.9971 ## [1] 257.9971 # 对连续型变量进行填补 df_miss_col %&gt;% mutate_if(is.double, ~replace_na(.x, median(.x, na.rm=TRUE))) ## # A tibble: 10 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_2 3730 258. &lt;NA&gt; ## 3 id_3 2600 230. M ## 4 id_4 2130 369. F ## 5 id_5 3730 258. F ## 6 id_6 1920 200. F ## 7 id_7 6415 277. F ## 8 id_8 1510 284. F ## 9 id_9 4860 237. M ## 10 id_10 6265 382. &lt;NA&gt; 使用众数填补缺失值。 # 构建众数函数 mode &lt;- function(x) { ux &lt;- unique(x) # 获取无重复元素的向量 ux[which.max(tabulate(match(x, ux)))] # 获取众数 } # 对字符型变量进行填补 df_miss_col %&gt;% mutate_if(is.character, ~replace_na(.x, mode(.x))) ## # A tibble: 10 × 4 ## ID air_time1 gmrt_in_air1 gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 121. M ## 2 id_2 NA NA F ## 3 id_3 2600 230. M ## 4 id_4 2130 369. F ## 5 id_5 NA 258. F ## 6 id_6 1920 200. F ## 7 id_7 6415 277. F ## 8 id_8 1510 284. F ## 9 id_9 4860 237. M ## 10 id_10 6265 382. F 使用mice包对缺失值进行多重插补（multiple imputation）。 多重插补法假设缺失值是随机发生的，使用链式方程对缺失值进行填补，具体步骤为： 从变量的实际观测值中随机取值对对应变量的缺失值进行填补。 移除第一个缺失变量中有缺失值的记录，以第一个缺失变量为因变量，其余变量为自变量构建回归方程，通过随机回归插补法（即在构建的回归方程中添加扰动项norm()）填补第一个缺失变量的缺失值。 以类似的方法对剩余缺失变量的缺失值进行填补。 步骤2和3完成1次为1个循环（iteration）。通常重复5-20个循环构建一组填补后的数据。 重复步骤4直至获得 m 组填补后的数据。缺失值填补部分到此结束 对 m 组数据分别进行统计分析，返回统计分析的平均结果。此步骤为后续统计分析过程 具体操作可参考这篇文章。 # 加载包 library(mice) # 数据处理 df_miss_col &lt;- df_miss_col %&gt;% filter(!is.na(gender)) %&gt;% # gender变量中有缺失的记录将被删除 mutate(gender=as_factor(gender)) # 将gender变量类型从字符型转换为分类变量 # 使用&quot;pmm&quot;法插补缺失值 impute_mice &lt;- mice(df_miss_col, method=&quot;pmm&quot;, printFlag=FALSE, seed=1) # 使用插补后的数据进行逻辑回归 fit_mice &lt;- with(impute_mice, glm(gender~air_time1+gmrt_in_air1, family=binomial(link=&#39;logit&#39;))) # 汇总逻辑回归结果 pooled_mice &lt;- pool(fit_mice) # 报告最终结果 summary(pooled_mice) ## term estimate std.error statistic df p.value ## 1 (Intercept) -8.2204661643 9.0793281103 -0.9054047 3.730475 0.4198889 ## 2 air_time1 -0.0003599382 0.0007634819 -0.4714430 3.443569 0.6656127 ## 3 gmrt_in_air1 0.0422655603 0.0452813630 0.9333986 3.687814 0.4075974 使用missForest包对缺失值进行填补。 missForest包先将缺失值用均值或众数进行填补，然后通过随机森林方法对填补值进行修正。与MICE不同，该方法是一种非参数填补法，当变量间的关系为非线性或者存在交互作用时，也有较好的填补效果。同时，该方法可以应用于混合数据类型（比如同时存在连续变量和分量变量缺失的情况）且在噪声数据（noisy data）下也有良好表现。缺点是样本量不能太少，对算力要求较高，耗时较长。具体介绍可参考这篇文章。 # 加载包 library(missForest) # 读取数据 df_miss &lt;- read_csv(&quot;data/darwin-missing.csv&quot;) ## Rows: 10 Columns: 5 ## ── Column specification ─────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): ID, gender ## dbl (3): air_time1, gmrt_in_air1, max_x_extension1 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # 保留缺失占比不超过20%的变量 df_miss_col &lt;- df_miss[, col_miss_count/nrow(df_miss) &lt;= 0.2] # 填补除第一列变量以外的所有变量 # impute_mf &lt;- missForest(df_miss_col[,-1]) # 直接运行此代码会报错 注意：如果直接运行最后一行代码会报错。 通过class()函数查看数据类型，可以发现，df_miss_col数据框的类型为： “tbl_df”和”tbl”是tidyverse的dplyr包默认的数据框处理和存储类型，它能更简洁地呈现数据并能更高效地对数据框进行处理与运算（详细介绍见此链接）。但是missForest处理对象为”data.frame”类型，因此需要进行数据框类型的转换。 # 加载包 library(missForest) # 读取数据 df_miss &lt;- read_csv(&quot;data/darwin-missing.csv&quot;) # 保留缺失占比不超过20%的变量 df_miss_col &lt;- df_miss[, col_miss_count/nrow(df_miss) &lt;= 0.2] %&gt;% mutate(gender=as.factor(gender)) %&gt;% # 将字符型变量转变为分类变量，才能进行填补 as.data.frame() # 将数据框转为&quot;data.frame&quot;类型 # 填补除第一列变量以外的所有变量 impute_mf &lt;- missForest(df_miss_col[,-1]) # 查看填补后的数据 impute_mf$ximp ## air_time1 gmrt_in_air1 gender ## 1 5160.000 120.8042 M ## 2 4111.035 277.6232 F ## 3 2600.000 229.9340 M ## 4 2130.000 369.4033 F ## 5 4336.855 257.9971 F ## 6 1920.000 199.7650 F ## 7 6415.000 276.5146 F ## 8 1510.000 284.0157 F ## 9 4860.000 236.8763 M ## 10 6265.000 381.9289 F 有时，我们需要对一些缺失值进行上下填补，这时可以使用fill()函数。 # 创建数据框 set.seed(1) sales &lt;- data.frame( quarter=c(rep(c(&quot;Q1&quot;,&quot;Q2&quot;,&quot;Q3&quot;,&quot;Q4&quot;), times=3)), year=c(NA,&quot;2001&quot;,NA,NA,&quot;2002&quot;,NA,NA,NA,&quot;2003&quot;,NA,NA,NA), values=floor(rnorm(n=12, mean=100, sd=12)) ) # 查看数据框 sales ## quarter year values ## 1 Q1 &lt;NA&gt; 92 ## 2 Q2 2001 102 ## 3 Q3 &lt;NA&gt; 89 ## 4 Q4 &lt;NA&gt; 119 ## 5 Q1 2002 103 ## 6 Q2 &lt;NA&gt; 90 ## 7 Q3 &lt;NA&gt; 105 ## 8 Q4 &lt;NA&gt; 108 ## 9 Q1 2003 106 ## 10 Q2 &lt;NA&gt; 96 ## 11 Q3 &lt;NA&gt; 118 ## 12 Q4 &lt;NA&gt; 104 # 对year填补 sales %&gt;% fill(year, .direction=&quot;downup&quot;) # 先向下填补，向下填补完后再向上填补 ## quarter year values ## 1 Q1 2001 92 ## 2 Q2 2001 102 ## 3 Q3 2001 89 ## 4 Q4 2001 119 ## 5 Q1 2002 103 ## 6 Q2 2002 90 ## 7 Q3 2002 105 ## 8 Q4 2002 108 ## 9 Q1 2003 106 ## 10 Q2 2003 96 ## 11 Q3 2003 118 ## 12 Q4 2003 104 2.4.5 数据整理 2.4.5.1 变量的拆分与合并 有些变量中包含的内容会以分隔符（如,、-、|、/等）的形式记录，而我们需要将这些记录拆分时，就需要用到separate_wider_*()函数。 # 将 region 变量拆分为 state 和 city df_darwin %&gt;% select(region) %&gt;% separate_wider_delim(region, delim=&quot;,&quot;, names=c(&quot;state&quot;, &quot;city&quot;), cols_remove=FALSE) %&gt;% head() ## # A tibble: 6 × 3 ## state city region ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 TX San Antonio TX,San Antonio ## 2 TX San Antonio TX,San Antonio ## 3 TX Austin TX,Austin ## 4 TX Houston TX,Houston ## 5 TX Dallas TX,Dallas ## 6 Ohio Columbus Ohio,Columbus 有时我们需要将变量中的记录拆分成列，就需要用到separate_longer_*()函数。 # 将region以&quot;,&quot;为分隔，拆分成行 df_darwin %&gt;% select(ID, air_time1, region) %&gt;% separate_longer_delim(region, delim=&quot;,&quot;) %&gt;% # 其余变量的值将被复制到新创建的行中 head() ## # A tibble: 6 × 3 ## ID air_time1 region ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 id_1 5160 TX ## 2 id_1 5160 San Antonio ## 3 id_2 51980 TX ## 4 id_2 51980 San Antonio ## 5 id_3 2600 TX ## 6 id_3 2600 Austin 使用unite()函数将多列按照特定分隔符合并为一列。 # 将region, gender, class变量合并为一列(new_var)，以-连接 df_darwin %&gt;% select(region, gender, class) %&gt;% unite(new_var, region:class, sep=&quot;-&quot;) %&gt;% head() ## # A tibble: 6 × 1 ## new_var ## &lt;chr&gt; ## 1 TX,San Antonio-M-P ## 2 TX,San Antonio-M-P ## 3 TX,Austin-M-P ## 4 TX,Houston-F-P ## 5 TX,Dallas-F-P ## 6 Ohio,Columbus-F-P 2.4.5.2 数据框的长宽转换 不同的数据分析方法需要不同的数据框输入格式，比如线性回归需要各个变量依次罗列，即宽数据格式（wide format），混合效应模型需要将不同时间点放在同一个变量下面，即长数据格式（long format），这就需要使用pivot_*()函数。 将宽数据格式转为长数据格式 # 读取数据 df_darwin &lt;- read_csv(&quot;data/darwin.csv&quot;) # 单变量转换 df_darwin %&gt;% select(ID, num_range(&quot;air_time&quot;, 1:5)) %&gt;% # 提取 air_time 1-5的变量 pivot_longer( # 转为长数据格式 cols = starts_with(&quot;air_time&quot;), # 选择目标变量 names_to = &quot;air_time&quot;, # 存储目标变量名称的新变量名称 names_prefix = &quot;air_time&quot;, # 识别目标变量的前缀，前缀之后的部分将转为新变量的元素 values_to = &quot;value&quot; # 存储目标变量原先数据的新变量名称 ) ## # A tibble: 870 × 3 ## ID air_time value ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id_1 1 5160 ## 2 id_1 2 6085 ## 3 id_1 3 4345 ## 4 id_1 4 30625 ## 5 id_1 5 66034 ## 6 id_2 1 51980 ## 7 id_2 2 10515 ## 8 id_2 3 15885 ## 9 id_2 4 7975 ## 10 id_2 5 12875 ## # ℹ 860 more rows # 多变量转换 df_darwin %&gt;% select(ID, starts_with(c(&quot;air_time&quot;,&quot;gmrt_in_air&quot;))) %&gt;% # 提取 air_time 和 gmrt_in_air 1-5的变量 pivot_longer( # 转为长数据格式 cols = !ID, # 提取除 ID 之外的所有变量 names_to = c(&quot;item&quot;, &quot;wave&quot;), # 构建存储目标变量和目标变量后缀的新变量名称 names_pattern = &quot;([\\\\w_]+)(\\\\d)&quot;, # 定义识别目标变量中想要提取元素（即括号内的元素）的正则表达式 values_to = &quot;value&quot; # 存储目标变量原先数据的新变量名称 ) ## # A tibble: 1,740 × 4 ## ID item wave value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 id_1 air_time 1 5160 ## 2 id_1 air_time 2 6085 ## 3 id_1 air_time 3 4345 ## 4 id_1 air_time 4 30625 ## 5 id_1 air_time 5 66034 ## 6 id_1 gmrt_in_air 1 121. ## 7 id_1 gmrt_in_air 2 269. ## 8 id_1 gmrt_in_air 3 330. ## 9 id_1 gmrt_in_air 4 233. ## 10 id_1 gmrt_in_air 5 126. ## # ℹ 1,730 more rows 将长数据格式转为宽数据格式 # 创建数据框 df_long &lt;- data.frame( ID = rep(c(1,2), each=4), quarter = rep(c(&quot;Q1&quot;,&quot;Q2&quot;,&quot;Q3&quot;,&quot;Q4&quot;), times=2), year = rep(c(2001,2002), each=4), value = 5:12 ) df_long %&gt;% pivot_wider( # 转为宽数据格式 names_from = quarter, # 依据目标变量将新生成的变量名称 values_from = value # 目标变量的数值 ) ## # A tibble: 2 × 6 ## ID year Q1 Q2 Q3 Q4 ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 2001 5 6 7 8 ## 2 2 2002 9 10 11 12 2.4.6 删除重复记录 当数据中出现重复记录的情况时，可以使用unique()和duplicated()函数删除重复记录。 df_duplicate &lt;- data.frame( ID = c(1,1,2,3), group = c(1,1,1,2), value = c(20,20,10,20) ) # 剔除所有变量均重复的记录，仅保留第一条重复记录 df_duplicate %&gt;% unique() ## ID group value ## 1 1 1 20 ## 3 2 1 10 ## 4 3 2 20 # 剔除特定变量有重复的记录，仅保留第一条重复记录 df_duplicate[!duplicated(df_duplicate$value),] ## ID group value ## 1 1 1 20 ## 3 2 1 10 2.4.7 按条件筛选记录 采用filter()函数可以根据变量内容筛选记录。 library(readxl) df_goods &lt;- read_excel(&quot;data/goods.xlsx&quot;) # 筛选amount&gt;=50，continent=&quot;Europe&quot;的记录 df_goods %&gt;% filter(amount&gt;=50 &amp; continent==&quot;Europe&quot;) ## # A tibble: 2 × 3 ## country continent amount ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Andorra Europe 55 ## 2 Belarus Europe 82 2.4.8 按条件创建变量 有时我们需要基于特定变量的值创建新的变量，这可以通过mutate()函数结合if_else()或case_when()函数实现。 # 创建数据框 df_bmi &lt;- data.frame( bmi = c(28.5, 26.3, NA, 23, NA, 17, 22.5) ) # 基于bmi数值创建新变量，将bmi划分为体重过低、体重正常、超重和肥胖4个等级 # 使用 if_else() 函数 df_bmi %&gt;% mutate( # 使用mutate()函数创建新变量 bmi_class = if_else( bmi &lt; 18.5, &quot;体重过低&quot;, if_else( bmi &lt; 24, &quot;体重正常&quot;, if_else( bmi &lt; 28, &quot;超重&quot;, &quot;肥胖&quot; ) ) ) ) ## bmi bmi_class ## 1 28.5 肥胖 ## 2 26.3 超重 ## 3 NA &lt;NA&gt; ## 4 23.0 体重正常 ## 5 NA &lt;NA&gt; ## 6 17.0 体重过低 ## 7 22.5 体重正常 # 使用case_when()函数 df_bmi %&gt;% mutate( bmi_class = case_when( bmi&lt;18.5 ~ &quot;体重过低&quot;, bmi&lt;24 ~ &quot;体重正常&quot;, bmi&lt;28 ~ &quot;超重&quot;, bmi&gt;=28 ~ &quot;肥胖&quot;, # TRUE ~ &quot;肥胖&quot; # 如果最后一个条件不做区分，完全用TRUE表示，则NA也会转为&quot;肥胖&quot; ) ) ## bmi bmi_class ## 1 28.5 肥胖 ## 2 26.3 超重 ## 3 NA &lt;NA&gt; ## 4 23.0 体重正常 ## 5 NA &lt;NA&gt; ## 6 17.0 体重过低 ## 7 22.5 体重正常 2.4.9 汇总函数summarise()与reframe() summarise()汇总函数，顾名思义，就是将数据进行汇总整理。如无特殊说明，则按变量返回一行汇总数据。如果与group_by()分组函数结合，则按照分组返回汇总数据。常用汇总计算的函数包括： mean()汇总均值。 median()汇总中位数。 sd()汇总标准差。 IQR()汇总四分位距。 min()汇总最小值。 max()汇总最大值。 n()总数。 n_distinct()非重复数。 注意： 上述现成函数在使用时需要写成~FUN(.x)（如~mean(.x)）的形式。 如果是自定义函数，可以直接写成function(x){}的形式。 如果想同时使用多个函数，可以用list()函数将目标函数合并。 # 导入数据 darwin_df &lt;- read_csv(&quot;data/darwin.csv&quot;) darwin_df %&gt;% select(gender,air_time1, gmrt_in_air1) %&gt;% # 选择变量 summarise( count = n(), # 计数 air_time1_avg = mean(air_time1), # 获取 air_time1 均值 gmrt_in_air1_median = median(gmrt_in_air1) # 获取 gmrt_in_air1 中位数 ) ## # A tibble: 1 × 3 ## count air_time1_avg gmrt_in_air1_median ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 174 5664. 256. darwin_df %&gt;% select(gender,air_time1, gmrt_in_air1) %&gt;% # 选择变量 group_by(gender) %&gt;% # 按照 gender 分组 summarise( count = n(), # 计数 air_time1_avg = mean(air_time1), # 获取 air_time1 均值 gmrt_in_air1_median = median(gmrt_in_air1) # 获取 gmrt_in_air1 中位数 ) ## # A tibble: 2 × 4 ## gender count air_time1_avg gmrt_in_air1_median ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 F 86 5452. 256. ## 2 M 88 5872. 258. # 依据特定条件批量汇总 darwin_df %&gt;% select(ends_with(&quot;1&quot;)) %&gt;% summarise_if( is.numeric, # 选择数字型变量 list(~mean(.x), ~median(.x)) # 分别计算各变量的均值与中位数 ) ## # A tibble: 1 × 12 ## air_time1_mean gmrt_in_air1_mean max_x_extension1_mean max_y_extension1_mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5664. 298. 1978. 7324. ## # ℹ 8 more variables: mean_acc_in_air1_mean &lt;dbl&gt;, mean_gmrt1_mean &lt;dbl&gt;, ## # air_time1_median &lt;dbl&gt;, gmrt_in_air1_median &lt;dbl&gt;, max_x_extension1_median &lt;dbl&gt;, ## # max_y_extension1_median &lt;dbl&gt;, mean_acc_in_air1_median &lt;dbl&gt;, mean_gmrt1_median &lt;dbl&gt; summarise()函数在不分组的情况下只能返回一行汇总数据。但是有些时候我们需要根据不同的先决条件返回不同的汇总数据，比如不同的百分数值返回不同的百分位数，这时就需要用到reframe()函数。具体应用我们在across()函数中会说明。 2.4.10 across()函数 有时我们只想对特定的若干变量做相同的处理，比如上例2.4.9中如果想对除air_time1和max_x_extension1以外的数字型变量做均值统计，这时可以考虑across()函数。 # 导入数据 darwin_df &lt;- read_csv(&quot;data/darwin.csv&quot;) ## Rows: 174 Columns: 34 ## ── Column specification ─────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (4): ID, class, region, gender ## dbl (30): air_time1, gmrt_in_air1, max_x_extension1, max_y_extension1, mean_acc_in_air1... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. darwin_df %&gt;% select(ends_with(&quot;1&quot;)) %&gt;% reframe( prob = c(0.25, 0.75), # 设置百分数值 across( where(is.numeric) &amp; !c(&quot;air_time1&quot;, &quot;max_x_extension1&quot;), # 遍历非 air_time1 和 max_x_extension1 的数字型变量 ~quantile(.x, prob, na.rm=TRUE) # 基于prob的百分数值，计算各变量的百分位数 ) ) ## # A tibble: 2 × 5 ## prob gmrt_in_air1 max_y_extension1 mean_acc_in_air1 mean_gmrt1 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.375 174. 6124 0.218 161. ## 2 0.625 359. 8298. 0.443 294. 2.4.11 日期处理 由于日期通常在导入数据时会被自动定义为字符型（可以先使用str()函数查看变量类型），所以需要使用parse_datetime()函数将字符型日期转换成POSIXct形式。在表示日期形式时，需要了解各字母符号的含义，主要内容如下： 年的表示：%Y为四位数的年份，%y为两位数的年份。 月的表示：%m为两位数的月份。 日的表示：%d为两位数的日期。 时的表示：%H为两位数的小时数。 分的表示：%M为两位数的分钟数。 秒的表示：%S为两位数的秒数。 比如 “23/11/2023 14:33:06” 可以表示为 “%d/%m/%Y %H:%M:%S”。 要计算两个日期之间的天数差，可以使用difftime()函数，并可以使用time_length()函数基于天数差计算月数或者年数差。 如果需要单独提取年、月、日数据，可以使用year()、month()、day()函数或者format()函数。 # 创建数据框 df_date &lt;- data.frame( ID = 1:3, birthday = c(&quot;1958-12-01&quot;, &quot;1954-10-01&quot;, &quot;1956-09-20&quot;), testday = &quot;2022-05-06&quot; ) # 检查变量类型，日期都是字符型 str(df_date) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ ID : int 1 2 3 ## $ birthday: chr &quot;1958-12-01&quot; &quot;1954-10-01&quot; &quot;1956-09-20&quot; ## $ testday : chr &quot;2022-05-06&quot; &quot;2022-05-06&quot; &quot;2022-05-06&quot; df_date %&gt;% mutate( across(c(birthday,testday), ~parse_datetime(.x, &quot;%Y-%m-%d&quot;)), # 需要将日期从字符型转换成日期类型 diff_days = difftime(testday, birthday, units=&quot;days&quot;), # 计算日期间的天数差 diff_year = time_length(diff_days, &quot;years&quot;), # 计算日期间的年数差 birth_year = year(ymd(birthday)), # 提取出生年份 test_year = format(testday, &quot;%Y&quot;) # 提取测试年份 ) ## ID birthday testday diff_days diff_year birth_year test_year ## 1 1 1958-12-01 2022-05-06 23167 days 63.42779 1958 2022 ## 2 2 1954-10-01 2022-05-06 24689 days 67.59480 1954 2022 ## 3 3 1956-09-20 2022-05-06 23969 days 65.62355 1956 2022 "]]
